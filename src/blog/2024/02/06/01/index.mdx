---
title: "2의 보수"
date: 2024-02-06T14:00:00+09:00
summary: "모듈러 연산으로 바라보는 2의 보수"
thumbnail: "/src/assets/thumbnails/2024/02/06/01/thumbnail.webp"
---

import L from "@/components/post/AltLang.astro";
import Figure from "@/components/post/FigureV2.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";

import fig1 from "@texfigs/2024/02/06/01/fig1.svg";
import fig2 from "@texfigs/2024/02/06/01/fig2.svg";



컴퓨터가 숫자를 기억할 때 크게 두 가지 방법이 있습니다.
부호가 있는<L>signed</L> 수와 부호가 없는<L>unsigned</L> 수인데요.
C 언어와 같은 프로그래밍 언어는 이 둘을 명시적으로 구분합니다.

```c
signed int a = -1; // signed integer
unsigned int b = 1; // unsigned integer
```

부호가 없는 수는 이진법 표현을 비트<L>bit</L>로 그대로 표현할 수 있고, 부호가 있는 수는 2의 보수<L>two's complement</L>를 보통 이용하곤 합니다.

여기서 숫자 $n$의 2의 보수란, 충분히 큰 2의 제곱 수 $2^M$에서 $n$을 뺀 수를 말합니다.
예를 들어 $-1$의 비트 표현을 얻기 위해, $2^8$에서 $1$을 뺀 수 $255$를 구합니다.
이는 이진수로 $1111 \thinspace 1111_{(2)}$이고, 이것이 곧 $-1$의 비트 표현이 됩니다.

사실 이것만으로 2의 보수 얘기는 끝낼 수 있습니다.
하지만 모듈러 연산을 통해 다른 시각으로 바라보는 방법을 소개하려고 합니다.
그러면 부호가 없는 수나 2의 보수나 똑같은 계산 방법으로 다룰 수 있습니다.
그리고 정수 오버플로우<L>integer overflow</L>를 값이 '넘치는 것'으로 보는 대신 모듈러 연산에서 나타나는 하나의 성질로 볼 수 있습니다.
여기서 모듈러 연산이 무엇인지 모르더라도 앞으로 소개하는 내용을 통해 이해할 수 있을 것입니다.



# 모듈러 연산과 2의 보수

모듈러 연산<L>modular arithmetic</L>이란 모듈로<L>module</L>라고 하는 수를 정해서, 두 수의 차이가 모듈로의 배수라면 합동<L>congruent</L>이라고 보는 것입니다.

예를 들어, $1$과 $9$는 모듈로 $8$에 대해 합동입니다.
그리고 이 사실은 다음과 같이 표현합니다.

$$
1 \equiv 9 \mod 8
$$

양수에 대해서는 모듈로 $8$로 나눈 나머지가 같기 때문이라고도 할 수 있습니다.
하지만 음수도 얼마든지 합동을 말할 수 있습니다.

$$
1 \equiv -7 \mod 8
$$

그러면 부호가 없는 수든 2의 보수든 상관없이 똑같은 모듈러 연산으로 계산할 수 있습니다.
예를 들어, $64+65$를 이진수로 표현한 덧셈을 봅시다.

$$
\begin{align*}
  {} & 64                         && {}+{} &&65                         && {}= 129                        \\
  {} & 0100 \thinspace 0000_{(2)} && {}+{} &&0100 \thinspace 0001_{(2)} && {}= 1000 \thinspace 0001_{(2)}
\end{align*}
$$

만약 8비트 데이터 타입으로 `64+65`를 계산했다고 해봅시다.
그러면 부호가 없는 타입일 땐 `129`가 되고, 부호가 있을 땐 `-127`이 됩니다.

```c
printf("%d\n", (unsigned char)(64 + 65)); // 129  (1000 0001)
printf("%d\n", (  signed char)(64 + 65)); // -127 (1000 0001)
```

하지만 컴퓨터는 부호가 있거나 없거나 상관 없이 위 결과처럼 `1000 0001`을 낼 뿐입니다.

여기서 모듈로를 $2^8=256$으로 해봅시다.
그러면 두 결과 `129`와 `-127`은 합동이 됩니다.

$$
129 \equiv -127 \mod 256
$$

즉 부호가 있거나 없거나 똑같이 모듈러 연산으로 덧셈을 할 수 있는 것입니다.



# 비트 표현과 해석

메모리에 담긴 비트는 그 자체로 아무런 의미도 갖지 않습니다.
그 비트를 사용하는 입장에서 해석을 결정합니다.
여기서는 가상의 4비트 데이터 타입을 통해 그 해석이 어떻게 부호가 없는 수와 2의 보수로 이어지는지 볼 것입니다.

## 4비트 해석 규칙 만들기

4비트 메모리가 있다고 해봅시다.
예를 들어, 여기에 `1111`이 들어있다면 곧 이진수 $1111_{(2)}$를 의미하는 것입니다.
여기서 $2^4=16$을 모듈로로 하면, 이 숫자는 모든 정수 $n$에 대해 $15+16n$와 합동이 됩니다.

$$
1111_{(2)} \equiv 15 + 16n \mod 16
$$

위 식에서 $n=0, 1$인 경우를 통해, $1111_{(2)}$는 $15$, $-1$과 합동임을 알 수 있습니다.

$$
\begin{align*}
  1111_{(2)} &\equiv 15 + 0 \equiv 15  &&\mod 16 \\
  1111_{(2)} &\equiv 15 - 16 \equiv -1 &&\mod 16
\end{align*}
$$

이를 이용해 비트 표현 `1111`은, 부호가 없는 수로서 $15$로, 부호가 있는 수로서 $-1$로 해석할 수 있습니다.
즉 같은 비트 표현이라도 상황에 따라 이렇게 다르게 이해하기로 약속할 수 있습니다.

다른 비트 표현도 마찬가지입니다.
네 개의 비트는 16가지 경우를 만들 수 있으므로, 각 16종류의 합동마다 하나의 숫자를 선택할 수 있습니다.
그렇게 숫자를 16개 모아서 비트 표현의 해석 규칙을 만들 수 있습니다.

예를 들어, $n=0$ 인 경우를 봅시다.
그러면 각 비트 표현은 자연스럽게 부호가 없는 값으로 해석됩니다.

<Figure src={fig1} alt="unsigned number">
  <FigureCaption slot="caption">그림 1. 부호가 없는 수로 해석하는 비트 표현.</FigureCaption>
</Figure>

한편, $n=-1$ 일 때를 봅시다.
그러면 이번에는 각 비트 표현이 2의 보수로 해석됩니다.

<Figure src={fig2} alt="signed number">
  <FigureCaption slot="caption">그림 2. 부호가 있는 수로 해석하는 비트 표현.</FigureCaption>
</Figure>

비트가 몇개더라도 이런 규칙을 만들어낼 수 있습니다.
아래 C 코드에서 볼 수 있듯이, 비트 표현 $1111 \thinspace 1000_{(2)}$는 부호가 없는 수로서 `248`로, 2의 보수로서 `-8`로 해석됩니다.

```c
printf("%d\n", (unsigned char)( -8)); // 248
printf("%d\n", (  signed char)(248)); // -8
```

이 두 수는 $2^8$을 모듈로로 합동입니다.


# 모듈러 연산과 오버플로우

다시 가상의 4비트 데이터 타입을 떠올려봅시다.
여기서 부호가 없는 숫자로서 $8$과 $9$를 더하면 $1$이 될 것입니다.
왜냐면 비트가 네 개인 메모리 공간에서 $2^4=16$은 오버플로우로 인해 버려지기 때문입니다.

이런 오버플로우의 효과는 모듈러 연산에서 자연스럽게 나타납니다.

$$
8 + 9 \equiv 1 \mod 2^4
$$

비트 표현을 이진수 그대로 옮기더라도, 모듈러 연산으로 똑같은 사실을 나타낼 수 있습니다.

$$
1000_{(2)} + 1001_{(2)} = 0001_{(2)} \mod 10000_{(2)}
$$

여기서 비트 $0001_{(2)}$는 `1`로 해석되므로, 오버플로우 효과가 적용되어 `17`이 되지 않습니다.

그럴 수밖에 없는 이유는 $2^4$를 모듈로로 했기 때문에, 4비트를 넘어가는 값은 자연스럽게 무시되기 때문입니다.
즉 $M$비트 데이터 타입 간 덧셈은, $2^M$을 모듈로로 하는 것으로 볼 수 있습니다.

한편, 잠시 부호가 있는 수로 생각하면 $1000_{(2)}$는 $-8$이고 $1001_{(2)}$는 $-7$이 됩니다.
그리고 이 두 수의 합 또한 $1$과 합동입니다.

$$
-8 + -7 \equiv 1 \mod 2^4
$$

즉 2의 보수의 경우에도 모듈러 연산의 결과에는 자연스럽게 오버플로우가 일어납니다.

사실 $8 + 9$나 $-8 + -7$은 모듈러 연산에서 같은 것이기 때문에 어찌 보면 당연한 결과입니다.

$$
8 + 9 \equiv -8 + -7 \mod 2^4
$$

비트 표현으로 모듈러 연산을 하는 것과, 비트 표현을 어떤 숫자로 해석하는지는 별개이기 때문입니다.

## 예시: 32비트 오버플로우

실제 32비트 데이터 타입을 예로 들어봅시다.
$2^{32}$를 모듈로로 하면 $2^{32}-1$가 $-1$과 합동이라는 사실은 바로 알 수 있습니다.

$$
2^{32\mathstrut}-1 \equiv -1 \mod 2^{32}
$$

이것은 `4294967295` 같은 숫자가 `-1`이라는 엉뚱해 보이는 값을 갖게되는 이유입니다.
(물론 `int` 타입이 32비트라고 가정한 것입니다.)

```c
int a = 4294967295; // 2^32 - 1
printf("%d", a);
// result: -1 // [!code highlight]
```

똑같은 이유로 부호가 없는 `int` 타입에서 `-1`이 반대로 그런 숫자가 됩니다.

```c
unsigned int a = -1;
printf("%u", a);
// result: 4294967295 // [!code highlight]
```



# 2의 보수 구하기

2의 보수 상에서, 양수 $n$에서 음수 $-n$을 구하는 방법을 보통 다음과 같이 소개합니다.

1. 비트 표현에서 `0`과 `1`을 서로 바꾼다.
1. 하나를 더한다.

예를 들어, 숫자 $7$에서 음수 $-7$의 비트 표현을 구해야 한다고 해봅시다.
그러면 $7$의 비트 표현이 `0111`이기 때문에, `1000`에서 `1`을 더해 `1001`로 답을 얻게 됩니다.

## 모듈러 연산에서 유도하기

이 계산법은 모듈로로 선택한 수, 즉 $2^M \equiv 0$으로부터 나오는 결과입니다.

어떤 수 $n$이 있다고 해봅시다.
이 수의 비트 표현에서 `0`과 `1`을 서로 바꾼 수를 $\bar{n}$라고 부릅시다.

$\bar{n}$은 `1`로 채워진 비트 `111...1`에서 $n$을 뺀 것입니다.
그런데 `1`로 채워진 비트란 곧 $2^M-1$입니다.
따라서 이 내용을 표현하자면 다음과 같습니다.

$$
\bar{n} = 2^M - 1 - n
$$

이로부터 $-n$을 모듈러 연산으로 다음처럼 구할 수 있습니다.

$$
\begin{align*}
  & \bar{n} = 2^M - 1 - n \equiv -n - 1 \mod 2^M \\
  \therefore \quad & {-n} \equiv \bar{n} + 1 \mod 2^M
\end{align*}
$$

이 결과가 의미하듯, $-n$은 $n$의 비트 표현에서 `0`과 `1`을 바꾸고 `1`을 더한 것이 됩니다.
즉 2의 보수를 얻는 계산법은 곧 모듈러 연산의 성질임을 알 수 있습니다.



# 마치며

2의 보수를 모듈러 연산으로 다시 설명해보았습니다.
모듈러 연산은 2의 보수 뿐만 아니라 부호가 없는 수에도 똑같은 방법으로 계산이 가능했습니다.
그리고 모듈러 연산의 결과는 자연스럽게 오버플로우를 반영하는 결과로 나타난다는 것을 보았습니다.

정수를 취급하는 컴퓨터는 정수론<L>number theory</L>과 밀접한 관련이 있을 수 밖에 없습니다.
모듈러 연산은 정수론에서 흔하게 사용되는 연산이기 때문에, 모듈러 연산에 대한 참고 자료는 정수론을 다루는 자료에서 쉽게 찾아볼 수 있습니다.

## 레퍼런스

- _Elementary Number Theory_ (Kenneth H. Rosen, 2011)

- _Computer Organization and Design_ (David Patterson, John Hennessy, 2013), 또는 _컴퓨터 구조 및 설계_ (2015)
