---
title: "사람들은 컴퓨터를 어떻게 생각해냈을까"
date: 2023-11-17T04:00:00+09:00
summary: "논리학에서 컴퓨터까지 빠르게 훑어보기"
thumbnail: "./_figs/thumbnail.webp"
---

import AltLang from "@components/post/AltLang.astro";
import Figure from "@components/post/Figure.astro";
import Quote from "@components/post/Quote.astro";
import FigureDisplay from "@components/post/FigureDisplay.astro";

import fig2 from "./_figs/fig2.webp";
import fig3 from "./_figs/fig3.webp";
import fig4 from "./_figs/fig4.webp";
import fig5 from "./_figs/fig5.webp";
import fig6 from "./_figs/fig6.webp";

<Quote>
  수학이란 우리가 무엇에 대해 말하고 있는지, 우리가 말하는 것이 맞는지 절대 알 수 없는 분야라고 할 수 있다.
  -- 버트런드 러셀

  Mathematics may be defined as the subject in which we never know what we are talking about, nor whether what we are saying is true.
  -- Bertrand Russell
</Quote>

컴퓨터 과학의 역사를 거슬러 올라가다보면 수학이 근본적인 위기를 맞이했던 시대를 만나게 됩니다.
그 위기의 시작은 이런 질문의 모습을 하고 있는데요.

"스스로 면도하지 않는 사람만 면도하는 사람이 있습니다.
이 사람은 자신의 수염을 면도할까요?"

두 결론 중 어느 한쪽을 가정해보세요.
어느 쪽이든 모순을 만나게 되는데요.
[이발사의 역설][wp-barber]<AltLang>Barber paradox</AltLang>이라고 불리는 이 문제는 단순한 연역법<AltLang>Deduction</AltLang>으로 수학의 기반인 논리학을 흔들었습니다.

[wp-barber]: https://ko.wikipedia.org/wiki/%EC%9D%B4%EB%B0%9C%EC%82%AC%EC%9D%98_%EC%97%AD%EC%84%A4

[힐베르트][wp-hilbert]<AltLang>David Hilbert</AltLang>는 이런 모순을 수학에서 걷어내고 싶었습니다.
그리고 힐베르트가 생각하기에 이상적인 수학의 모습을 제시했는데요.
수학이 실제로 그런 모습이라는 증명이 이루어지길 바랐습니다.

[wp-hilbert]: https://ko.wikipedia.org/wiki/%EB%8B%A4%EB%B9%84%ED%8A%B8_%ED%9E%90%EB%B2%A0%EB%A5%B4%ED%8A%B8

하지만 어떤 세 명의 인물이 차례로 그 반대의 것, 다시 말해 수학이 무엇을 할 수 없는지를 보였습니다.
그 인물은 [쿠르트 괴델][wp-godel]<AltLang>Kurt Gödel</AltLang>, [앨런 튜링][wp-turing]<AltLang>Alan Turing</AltLang>, 그리고 [알론조 처치][wp-church]<AltLang>Alonzo Church</AltLang>입니다.
그런데 역설적이게도 그 과정에서 반대로 우리가 무엇을 기계적으로<AltLang>Mechanically</AltLang> 할 수 있는지 보게 됩니다.

[wp-godel]: https://ko.wikipedia.org/wiki/%EC%BF%A0%EB%A5%B4%ED%8A%B8_%EA%B4%B4%EB%8D%B8
[wp-turing]: https://ko.wikipedia.org/wiki/%EC%95%A8%EB%9F%B0_%ED%8A%9C%EB%A7%81
[wp-church]: https://ko.wikipedia.org/wiki/%EC%95%8C%EB%A1%A0%EC%A1%B0_%EC%B2%98%EC%B9%98

힐베르트는 구체적으로 무엇을 요구했고, 왜 그랬던 것일까요?
그리고 이로부터 어떻게 컴퓨터가 나올 수 있었을까요?
어려운 디테일은 좀 빼놓고 그 역사를 훑어보겠습니다.


<FigureDisplay>
  <Figure
    src={fig2}
    alt="Mirror reflection" />
</FigureDisplay>


# 자기 자신을 언급하는 문제

논리적인 방법만을 거쳐서 모순을 이끌어낼 수 있다면 어떨까요?

앞서 언급했던 이발사의 역설이 그런 문제인데요.
비슷한, 그렇지만 좀 더 수학에 직접적으로 관련된 것을 만들 수 있습니다.
자기 자신을 원소로 갖지 않는 집합<AltLang>Set</AltLang>이 그런 것입니다.
그러면 이 집합은 자기 자신을 갖고 있을까요?

즉 집합 $A = \{ x : x \not\in x \}$가 있을 때, $A \in A$인지 $A \not\in A$인지를 묻는 질문인데요.
어느 쪽을 가정하든, 그 반대 쪽 또한 동시에 참이 됩니다.

$A \in A$라고 해봅시다.
그러면, 원소가 될 조건 $x \not\in x$를 만족시킬 텐데요.
따라서 $A \not\in A$가 되어 모순을 만들게 됩니다.
(반대쪽, 즉 $A \not\in A$을 가정했을 경우는 직접 해보세요.)

이것은 [러셀의 패러독스][wp-russell-paradox]<AltLang>Russell's paradox</AltLang>이라고 불리는데요.
집합 개념과 논리학만 가지고 만들어낸 이 모순은 수학에 근본적인 위협이 됐습니다.
수학은 증명에서 집합과 논리학을 일종의 기초적인 원리로서 사용했으니까요.

수학의 토대에 나타난 이 이상한 모습 때문에, 20세기 초는 집합과 논리에 대해 다시 생각해봐야 할 때였습니다.

[wp-russell-paradox]: https://ko.wikipedia.org/wiki/%EB%9F%AC%EC%85%80%EC%9D%98_%EC%97%AD%EC%84%A4

## 바닥부터 다시 짓기

무엇이 잘못일까요?

'스스로'나 '자기 자신' 같은 단어를 쓰면서 자기 언급을 하는 문장이 문제가 아닐까요?
그래서 이런 문장을 만들어내는 것을 처음부터 금지하면 문제가 해결되지 않을까요?

당시 [러셀][wp-russell]<AltLang>Bertrand Russell</AltLang>과 [화이트헤드][wp-whitehead]<AltLang>Alfred Whitehead</AltLang>는 수학을 바닥부터 다시 만들어냈습니다.
우리가 사용하는 논리적인 규칙을 분명하게 적어놓으면서요.

<Figure
  src={fig3}
  alt="Logical axioms"
  caption="수학 원리 책에서 쓰인 논리 규칙 일부" />

예를 들어, ``'A이다'가 맞는 문장이라면, 'A가 아니다'라는 문장은 틀린 문장이다.'' 라는 식으로요.
당연해 보이지만, 그 당연이라는 모습 뒤에 모순이 어쩌다가 숨어서 들어갈지도 모르니까요.

[wp-russell]: https://ko.wikipedia.org/wiki/%EB%B2%84%ED%8A%B8%EB%9F%B0%EB%93%9C_%EB%9F%AC%EC%85%80
[wp-whitehead]: https://ko.wikipedia.org/wiki/%EC%95%8C%ED%94%84%EB%A0%88%EB%93%9C_%EB%85%B8%EC%8A%A4_%ED%99%94%EC%9D%B4%ED%8A%B8%ED%97%A4%EB%93%9C

이런 논리 규칙을 가지고 $1 + 1 = 2$임을 이끌어 낼 수 있는 체계를 구성했습니다.
즉 이 논리 체계가 수학에 적용시킬 수 있을 만큼 충분히 쓸만하다는 것을 보인 것입니다.
그리고 이 결과를 [수학 원리][wp-principia]<AltLang>Principia Mathematica</AltLang>라는 책으로 내게 됩니다.
($1+1=2$임을 증명한 책으로 알려져 있지만, 그보다는 그것이 맞는 말인 논리 체계를 만들어냈다고 하는 것이 정확할 것입니다.)

[wp-principia]: https://ko.wikipedia.org/wiki/%EC%88%98%ED%95%99_%EC%9B%90%EB%A6%AC

## 피할 수 없는 자기 언급

그런데 괴델은 이 책의 내용을 그대로 이용해서 논문을 내는데요.
사실 이런 논리 체계 또한 불가피하게 자기 언급 문장이 만들어지는 것을 막을 수 없었습니다.
"이 문장은 증명할 수 없다." 같은 것처럼요.

그 문장이 실제로 증명할 수 없다면, 맞는 말이 될 텐데요.
하지만 그렇기 때문에, 그게 맞는 말인지는 증명할 수 없게 됩니다.
괴델은 이 작업을 통해, 어떤 말이 사실인 것과 그것을 증명할 수 있는 가능성은 별개의 것임을 보였습니다.

즉 괴델은 수학에는 증명할 수 없지만 참인 사실이 있다는 것을 보였는데요.
더 나아가, 사실은 러셀과 화이트헤드가 만들어낸 논리 체계뿐만 아니라, $1+1=2$가 맞는 그 어떤 논리 체계에서도 그런 문장을 만들 수 있다는 것도요.
그리고 이 결과는 [괴델의 불완전성 정리][wp-godel-incompleteness]<AltLang>Gödel's incompleteness theorems</AltLang>라는 이름으로 남게 됩니다.
(왜 이것이 불완전성인지는 곧 볼 것입니다.)

[wp-godel-incompleteness]: https://ko.wikipedia.org/wiki/%EA%B4%B4%EB%8D%B8%EC%9D%98_%EB%B6%88%EC%99%84%EC%A0%84%EC%84%B1_%EC%A0%95%EB%A6%AC


<FigureDisplay>
  <Figure
    src={fig4}
    alt="Building lego" />
</FigureDisplay>


# 존재의 의미

괴델은 왜 그런 문장을 굳이 직접 만들었을까요?

당시 [직관주의][wp-intuitionism]<AltLang>Intuitionism</AltLang>를 따르는 사람들은 실제로 만들어 낼 수 없으면 존재가 증명되지 않았다고 믿었습니다.
존재란 실제로 만들어냈거나, 그런 방법을 제시했을 때 입증된 것이라고 보았기 때문인데요.

[wp-intuitionism]: https://ko.wikipedia.org/wiki/%EC%A7%81%EA%B4%80%EC%A3%BC%EC%9D%98

그래서 [배중률][wp-excluded-middle]<AltLang>Law of excluded middle</AltLang>, 즉 어떤 문장도 맞거나 틀릴 뿐 그 중간은 없다고 배척한다는 원리는 유효한게 아니라고 보았습니다.
무언가가 존재하지 않는다고 가정했을 때 모순을 이끌어냈다고 해서, 그 무언가가 존재한다고 증명했다고는 생각하지 않았습니다.
직접 만들어 낸 것이 없으니까요.

어렵게 말하자면, 직관주의는 존재의 증명이 구성적<AltLang>Constructive</AltLang>이어야 한다고 요구했습니다.
(말 그대로, 구성해내야 하니까요.)
그래서 괴델은 1931년 논문에 ``직관주의적으로 반박할 수 없는 방식으로 증명했다<AltLang>proved in an intuitionistically unobjectionable manner</AltLang>'' 라는 문구를 더했습니다.

[wp-excluded-middle]: https://ko.wikipedia.org/wiki/%EB%B0%B0%EC%A4%91%EB%A5%A0


# 수학이라는 게임의 규칙

한편, 힐베르트는 비구성적인 방법으로 증명했다가 공격받은 적이 있는데요.
(힐베르트 기저 정리<AltLang>Hilbert's basis theorem</AltLang>라는 이름으로 남긴 했습니다.)
하지만 힐베르트는 모순만 일으키지 않는다면 존재는 증명된 것이라고 생각했습니다.
이런 그의 생각은 ``수학자가 배중률을 쓰지 못하도록 막는 것은 권투선수가 주먹을 쓰지 못하도록 막는 것''이라는 발언에서도 나타납니다.

그런데 힐베르트의 주변에서는 이 직관주의를 따르는 사람들이 생기기 시작했습니다.
하지만 힐베르트는 당장 무리수 개념조차 버리면서 직관주의를 따르고 싶지 않았고, 이 직관주의가 수학에 위협이라고 생각했습니다.

이후 힐베르트가 직관주의 없이도 이상적인 수학을 건설해내기 위해 힐베르트 프로그램<AltLang>Hilbert's program</AltLang>이라는 이름으로 그 과제를 시작했을 때, 직관주의자들 또한 승복할 수 있도록 만들어야 했습니다.
즉 증명은 구성적이어야 하고, (힐베르트가 말하길) &lsquo;유한한 방법<AltLang>Finitary method</AltLang>&rsquo;만을 써야 했습니다.
그리고 그런 결과 중 하나가 괴델의 작업이었습니다.


# 이상적인 수학의 모습

힐베르트는 난제를 제시하는 것으로 수학의 발전을 이끌려 했습니다.
그래서 1900년에 이르렀을 때 23개의 소위 [힐베르트 문제][wp-hilbert-problems]<AltLang>Hilbert's problems</AltLang>라고 부르는 것을 발표했는데요.
그 두 번째 문제는 산술 체계의 무모순성 증명, 즉 수학 체계에 모순이 없음을 증명하는 일이었습니다.

왜냐면 일년 전에 [기하학의 원리][wp-foundations-of-geometry]<AltLang>Foundations of geometry</AltLang>라는 책을 내면서,
기하학의 무모순성이 결국에는 산술 체계의 무모순성에 달려있다고 보였거든요.
그리고 남은 과제로서 두 번째 문제를 고른 것이었습니다.

[wp-hilbert-problems]: https://ko.wikipedia.org/wiki/%ED%9E%90%EB%B2%A0%EB%A5%B4%ED%8A%B8_%EB%AC%B8%EC%A0%9C
[wp-foundations-of-geometry]: https://en.wikipedia.org/wiki/Foundations_of_geometry

이후 1928년 국제 수학자 대회<AltLang>International congress of mathematicians</AltLang>에서 힐베르트는 목표를 좀 더 구체적으로 다듬었습니다.
힐베르트가 제시한 세 가지 과제는 이런 것이었는데요.
수학이 '완전'<AltLang>Complete</AltLang>한 지, '무모순적'<AltLang>Consistent</AltLang>인지, 그리고 '결정가능'<AltLang>Decidable</AltLang>한 지였습니다.

각각은 이런 의미가 있습니다.
'완전'하다는 것은, 모든 문장은 맞거나 틀리다고 증명될 수 있어야 한다는 뜻입니다.
그러니까 $1+1=2$라는 문장을 비롯해, 만들 수 있는 모든 문장에 대해서요.

'무모순적'이란, 논리적인 단계만 거쳤다면 모순이 없음이 보장되어야 한다는 의미입니다.
예를 들어, 제시된 논리 규칙만 따랐는데, $1+1=2$가 맞으면서 동시에 틀린 문장이 되어선 안됐습니다.

마지막으로 '결정가능'한 것이란, 어떤 문장에 대해서든 그것이 맞는지 틀린지 결정할 수 있는 절차가 있다는 것입니다.

이렇게 힐베르트가 제시한 성질을 증명한다면, 수학은 모순이 없고, 맞는 문장은 항상 증명할 수 있는 그런 학문이라고 알게 될 텐데요.
게다가 어떤 문장이든 결정가능기 때문에, 맞는지 틀린지 그저 기계적으로 알아낼 수 있게 됩니다.
(이렇게 수학자들은 전부 직업을 잃을 뻔했습니다.)

## 수학의 한계에서 잃은 것과 얻은 것

그런데 얼마 지나지 않아, 앞서 살펴본 것처럼, 괴델은 수학이 완전하지 않다는 것을 보이게 됩니다.
즉 맞는지 틀린지 증명할 수 없는 문장을 직접 만들어냅니다.
(그래서 괴델의 작업에 불완전성 정리라는 이름이 붙었습니다.)

그리고 ``수학은 무모순적이다'' 라는 문장도 바로 그런 문장이라는 것을 보이게 되는데요.
다시 말해 수학 그 자체로는 그 수학이 모순이 없는지 증명할 수 없다는 것을 보이게 됩니다.
이렇게 첫 번째와 두 번째 문제에 괴델은 부정적인 답을 하게 됩니다.

마지막으로 남은 세 번째는 소위 결정문제<AltLang>Entscheidungsproblem</AltLang>라는 이름을 갖고 있는데요.
이 문제의 답은 앨런 튜링와 알론조 처치가 각자 다른 방법으로 보이게 됩니다.
모든 문장에 참인지 거짓인지를 결정하는 절차는 없다는 것을요.
(수학자들의 직업을 지켰습니다.)

그 과정에서 튜링은 오늘날 [튜링 머신][wp-turing-machine]<AltLang>Turing machine</AltLang>이라고 하는 개념적인 기계를 떠올렸습니다.
그리고 처치는 [람다 대수][wp-lambda-calculus]<AltLang>Lambda calculus</AltLang>라고 이름 붙인, 일종의 형식 체계<AltLang>Formal system</AltLang>를 고안해냈습니다.
(그게 무엇인지는 곧 볼 것입니다.)
이후에 튜링은 이 두 가지가 사실상 같은 것을 해낼 수 있는 모델임을 보였습니다.

[wp-turing-machine]: https://ko.wikipedia.org/wiki/%ED%8A%9C%EB%A7%81_%EA%B8%B0%EA%B3%84
[wp-lambda-calculus]: https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98

특히 튜링은 [정지 문제][wp-halting-problem]<AltLang>Halting problem</AltLang>라고 이름 붙인 그 문제가, 결정 절차를 알아낼 수 없는 바로 그것임을 보였습니다.
그러니까 오늘날 컴퓨터의 개념적인 모델이 된 튜링 머신은, 기계가 무엇을 할 수 없는지 보이기 위해 고안한 장치였습니다.

하지만 한 쪽 경계가 반대쪽도 결정하는 것처럼, 이 튜링 머신을 통해 계산 가능<AltLang>Computable</AltLang>한 것이 무엇인지 검토할 수 있게 됐는데요.
이렇게 튜링 머신으로 할 수 있는 일을, 그리고 그것만을 알고리즘<AltLang>Algorithm</AltLang>이라고 부르게 되었습니다.
이는 컴퓨터 과학의 근본적인 가정인 [처치-튜링 명제][wp-church-turing-thesis]<AltLang>Church-Turing thesis</AltLang>으로 남게 되었습니다.

[wp-halting-problem]: https://ko.wikipedia.org/wiki/%EC%A0%95%EC%A7%80_%EB%AC%B8%EC%A0%9C
[wp-church-turing-thesis]: https://ko.wikipedia.org/wiki/%EC%B2%98%EC%B9%98-%ED%8A%9C%EB%A7%81_%EB%85%BC%EC%A0%9C


# 숫자로서의 컴퓨터

<Figure
  src={fig6}
  alt="ENIAC"
  caption="에니악과 배선판의 모습" />

1940년대에 최초의 컴퓨터라고 알려진 [에니악][wp-eniac]<AltLang>ENIAC</AltLang>이 만들어졌을 때에도, 프로그램과 데이터는 별개의 것으로 디자인 됐는데요.
명령들, 즉 프로그램은 외부에서 배선판의 수많은 선을 다시 꽂는 것으로 준비해야 했습니다.

[wp-eniac]: https://ko.wikipedia.org/wiki/%EC%97%90%EB%8B%88%EC%95%85

한편, 튜링이 생각했던 트릭은 다른 튜링 머신을 따라하는 튜링 머신을 만들어낸 것이었습니다.
이를 보편 튜링 머신<AltLang>Universal Turing machine</AltLang>이라고 불리는데요.

사실 튜링 머신에도 고유한 숫자를 적절히 부여할 수 있었습니다.
튜링이 부르길 [디스크립션 넘버][wp-description-number]<AltLang>Description number</AltLang>라고 하는 것을요.
그 숫자는 그 튜링 머신이 하는 일을 담을 수 있는데요.
(그래서 설명<AltLang>Description</AltLang>하는 숫자입니다.)
덕분에 보편 튜링 머신은 그 숫자를 읽어 그 튜링 머신이 하는 것을 똑같이 시뮬레이션 할 수 있었습니다.

[wp-description-number]: https://en.wikipedia.org/wiki/Description_number

그런데 이 관점에서는 어떤 프로그램을 수행하는 튜링 머신이라도, 결국 보편 튜링 머신 입장에서는 읽어야할 데이터가 됩니다.
프로그램 또한 데이터로서 추상화된 것입니다.

현대의 컴퓨터와 비교해보세요.
프로그래머가 명령을 작성하면, 컴파일러라는 프로그램은 그것을 받아 하나의 숫자를 만들어냅니다.
(보통 이진수로요.)
그리고 컴퓨터는 그 숫자를 읽고 바로 그 명령을 수행합니다.
여기서 이 숫자는 곧 디스크립션 넘버로, 그리고 컴퓨터는 보편 튜링 머신으로 생각해볼 수 있습니다.
오늘날 컴퓨터를 보편 튜링 머신의 구현으로 바라볼 수 있는 이유입니다.

## 실제로 만들기

튜링 머신은 힐베르트의 결정 문제를 풀기 위해 생각해냈던 추상적인 개념이었지만, 곧 현실에서 만들어보려는 시도가 나타났는데요.
튜링은 자신의 아이디어를 [ACE][wp-ace]라는 이름의 컴퓨터로 제작을 시작했던 튜링은 완성으로 끝내지는 못했습니다.

[wp-ace]: https://en.wikipedia.org/wiki/Automatic_Computing_Engine

한편 [폰 노이만][wp-neumann]<AltLang>John von Neumann</AltLang>은 이를 현실에서 만들어보려고 했습니다.
에니악 제작에 참여했던 폰 노이만은 다음에 만들 [에드박][wp-edvac]<AltLang>EDVAC</AltLang>이라는 컴퓨터로 관심을 옮겼는데요.
[에드박의 첫 번째 초안][wp-edvac-draft]에서 보편 튜링 머신의 물리적인 모형으로 만들 것을 제안했습니다.
즉 데이터와 명령을 모두 담는, 폰 노이만이 부르길 메모리라는 것을 더하는 것을요.
이 디자인은 이후에 [폰 노이만 아키텍처][wp-von-neumann-arch]<AltLang>von Neumann Architecture</AltLang>라는 이름으로 남게 됩니다.

[wp-neumann]: https://ko.wikipedia.org/wiki/%EC%A1%B4_%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C
[wp-edvac]: https://ko.wikipedia.org/wiki/%EC%97%90%EB%93%9C%EB%B0%95
[wp-edvac-draft]: https://en.wikipedia.org/wiki/First_Draft_of_a_Report_on_the_EDVAC
[wp-von-neumann-arch]: https://ko.wikipedia.org/wiki/%ED%8F%B0_%EB%85%B8%EC%9D%B4%EB%A7%8C_%EA%B5%AC%EC%A1%B0


<FigureDisplay>
  <Figure
    src={fig5}
    alt="Building lego" />
</FigureDisplay>


# 무의미한 기호 조작

다시 시간을 되돌려 덧붙일 이야기가 있습니다.

힐베르트는 수학적인 문장 그 자체에는 아무런 의미가 없다고 보았습니다.
점, 선, 면이라는 단어를 책상, 의자, 맥주컵으로 바꿔치더라도, 바로 그 책상, 의자, 맥주컵이 기존에 점, 선, 면이 따르던 규칙을 따르기만 하면 아무 문제가 없다고 생각했는데요.

예를 들어, &lsquo;선에는 무한히 많은 점이 있다.&rsquo;라는 문장을, &lsquo;의자에는 무한히 많은 책상이 있다.&rsquo;라고 고쳐쓰는 것처럼요.
왜냐면 사실 점, 선, 면 같은 것은 정의<AltLang>Definition</AltLang>가 없는, 즉 무정의 용어<AltLang>Undefined term</AltLang>로 남겨뒀거든요.
그래서 뭐라고 바꿔 부르든 간에, 실제로 현실에서 무엇을 가리키는 지는 신경쓰지 않았습니다.
그저 무정의 용어들이 문장에서 말하는 그 관계를 유지하기만 하면 그만이었습니다

그런데 이런 식으로 생각하면, 수학이란 단순히 $1+1+1$ 같은 기호들의 나열에서 적절한 규칙을 따라 조작해 $2+1$ 같은 또 다른 기호들의 나열을 만들어내는, 즉 기호 조작의 학문으로 볼 수 있습니다.
그 기호가 실제로 무엇을 가리키는 지는 신경쓰지 않고요.
이런 관점을 [형식주의][wp-formalism]<AltLang>Formalism</AltLang>라고 불렀는데요.
힐베르트는 이를 대표하는 인물이었습니다.

[wp-formalism]: https://en.wikipedia.org/wiki/Formalism_(philosophy_of_mathematics)

형식주의는 이렇게 본질적으로 무의미한 체계를 만들고, 그 안에서 수학적인 정리를 만들었습니다.
즉 시작점이 되는 문장들을 공리<AltLang>Axioms</AltLang>라는 이름으로 선택하고, 문장의 조작 규칙을 추론 규칙<AltLang>Inference rule</AltLang>이라는 이름으로 만들었습니다.
이런 구성 요소를 한데 모아 형식 체계<AltLang>Formal system</AltLang>라고 불렀습니다.
처치의 람다 대수가 그런 형식 체계입니다.

이렇게 규칙에 따라 조작한 결과를 모아 정리<AltLang>Theorem</AltLang>라고 불렀습니다.
그러면 수학에서 정리를 이끌어낸다는 것은, 그저 기호를 잘 조작하는 행위에 불과하게 됩니다.

## 무엇인지 모르고 하는 계산

기호 조작이란 그전에 어떤 기호를 조작할 지 선택해야 하고, 바로 그 기호들이 모여 형식 언어<AltLang>Formal language</AltLang>라고 불리는 인공적인 언어가 필요하게 됩니다.

이런 형식 언어는 원하는 대로 만들어낼 수 있는데요.
대표적으로는 정규 언어<AltLang>Regular language</AltLang>가 있습니다.
이는 정규 표현식<AltLang>Regular expression</AltLang>이라고 불리는 것과 대응됩니다.
이보다 좀더 표현력이 강한 것으로 문맥 자유 언어<AltLang>Context-free language</AltLang>가 있습니다.

이 두 형식 언어는 각각 유한 상태 기계<AltLang>Finite-state machine</AltLang>와 푸시다운 오토마타<AltLang>Pushdown automata</AltLang>라고 하는 개념적인 기계와 사실상 같은 개념인데요.
즉 의미를 제거한 언어로부터, 그 언어를 이해하는 개념적인 기계가 존재합니다.
예를 들어 유한 상태 기계는 정규 표현식을 처리하는 데 쓸 수 있고요.
푸시다운 오토마타는 컴파일러가 프로그래밍 언어를 파싱하는 데 쓸 수 있습니다.

마치 자신이 무엇을 하는지 그 의미를 알지 못하면서 계산을 해내는 지금의 컴퓨터가 떠오르진 않으신가요.


# 마치며

오늘날의 컴퓨터가 왜 튜링 머신의 구현인지, 컴퓨터란 왜 본질적으로 하나의 숫자일 뿐인지, 왜 프로그램을 메모리에 내장하는 컴퓨터는 컴파일러가 필요할 수 밖에 없는지, 그리고 어째서 수학자, 나아가서 프로그래머가 사라질 수 없는지 이해가 되는 글이 된다면 좋겠습니다.

하지만 괴델과 튜링, 그리고 처치의 성과가 구체적으로 어떻게 달성되었는지는 다루지 않았는데요.
일부러 그런 디테일은 피했기 때문에 그 목표의 달성이 어려울 수도 있겠네요.
추후 기회가 생긴다면 다루도록 하겠습니다.

중간에 생략했던 (관심이 없다면 볼 필요 없는) 내용은 이런 것이 있습니다.

튜링 머신은 [계산 모델][wp-model-of-computation]<AltLang>Model of computation</AltLang>, 즉 개념적인 계산 기계라고 불리는데요.
사실 괴델 또한 그의 논문에서, 오늘날 [프리미티브 리커시브][wp-primitive-recursive]<AltLang>Primitive recursive</AltLang>라고 부르는, 반복적인 계산 절차를 담은 함수를 만들었습니다.
그리고 이를 확장한 제너럴 리커시브<AltLang>General recursive</AltLang>, 또는 뮤 리커시브<AltLang>μ-recursive</AltLang>라고 불리는 함수는 튜링 머신과 할 수 있는 일이 같은데요.
그러니 괴델과 튜링, 처치로 인해, 컴퓨터는 물리적으로 구현되기 전에 이미 세 가지 모습으로 인류의 머리속에 등장하고 있었던 것입니다.

[wp-primitive-recursive]: https://ko.wikipedia.org/wiki/%EC%9B%90%EC%8B%9C_%EC%9E%AC%EA%B7%80_%ED%95%A8%EC%88%98
[wp-model-of-computation]: https://en.wikipedia.org/wiki/Model_of_computation

또한 자연수의 개수가 $\aleph_0$로 가장 작은 무한이라는 것을 안다면, 각 튜링 머신에는 자연수의 디스크립션 넘버가 항상 부여되기 때문에, 세상에는 자연수의 개수만큼 튜링 머신이 존재한다는 것을 알 수 있는데요.
그러면 사람이 생각해 낼 수 있는 일이 자연수보다 더 많이 존재한다면, 벌써부터 튜링 머신은 해낼 수 없는 일이 존재한다는 것을 금방 알 수 있습니다.
그리고 정지 문제가 바로 그런 문제 중 하나가 되는 것이고요.

사람들은 러셀의 패러독스 같은 문제 때문에 집합과 논리학을 다시 생각할 기회를 가졌는데요.
이후 공리적인 방법으로 집합이라는 개념을 다시 정의해보기 시작했습니다.
다시 말해 무엇을 집합으로 부르고, 또 무엇을 집합으로 부르지 않을 것인지 구분했는데요.
이로부터 각 이론에 공헌한 사람들의 앞글자를 따서, ZF 집합론<AltLang>ZF set theory</AltLang>과 NGB 집합론<AltLang>NGB set theory</AltLang> 같은 이론이 나타나게 되었습니다.
차이가 있다면 NGB 집합론은 집합이라고 부를 수 없는 것을 위해 클래스<AltLang>class</AltLang>라는 개념을 더하고, ZF 집합론은 그런 것을 직접 언급하지는 않는다는 것입니다.

논리학은 일차 논리학<AltLang>First-order logic</AltLang>이 중요한 성과인데요.
여기서는 문장에서 '모든'이나 '어떤'이라는 단어를 제한된 수준에서만 쓸 수 있습니다.
여기서 설명하는 논리학은 ZF 집합론과 같이 다른 이론에서 쓸 수 있는 논리 체계를 제공하고요.
여기에서 또한 괴델의 불완전성 정리를 이끌어낼 수 있습니다.

## 참고 문헌

- The Universal Computer (Martin Davis, 2000) (또는, '수학자, 컴퓨터를 만들다' (2005))

  논리학에서 출발해 컴퓨터까지 다룹니다.
  힐베르트 프로그램을 비롯해 튜링 머신과 폰 노이만의 구현까지 소개하고 있습니다.

- Alan Turing (Douglas Hofstadter, 2014) (또는, '앨런 튜링의 이미테이션 게임' (2015))

  앨런 튜링의 생애를 비롯해, 그가 괴델과 처치로부터 받은 영향과, 튜링 머신의 수학적인 설명을 담고 있습니다.

- Godel: A Life of Logic (Werner DePauli, John Casti, 2000) (또는 '괴델' (2002))

  주로 괴델의 성과를 소개하지만, 여기서도 힐베르트를 비롯해 계산가능성과 같은 튜링과 성과 또한 담고 있습니다.

- On Formally Undecidable Propositions of Principia Mathematica and Related Systems I (Kurt Gödel, 1931)

  괴델이 구체적으로 어떻게 불완전성 정리를 이끌어냈는지는 이 논문에 담겨있습니다.

- Gödel's Proof (Ernest Nagel, James Newman, Douglas R. Hofstadter 2008) (또는 '괴델의 증명' (2010))

  위의 것 대신 쉬운 설명으로 이 책을 참고할 수 있습니다.
  사실 위의 논문은 46개의 보조 정리가 담겨있지만, 이 책은 괴델이 증명하고자 하는 바를 그런 보조 정리 없이 설명합니다.

- On Computable Numbers, with an Application to the Entscheidungsproblem (Alan Turing, 1936)

  튜링이 튜링 머신, 또는 그가 '머신' 이라고 부른 것과, 계산 가능한<AltLang>Computable</AltLang> 것의 설명이 이 논문에 담겨있습니다.
  앞서 말한 괴델의 논문을 본문에서 언급하고 있기 때문에, 괴델의 작업을 알고 있다면 이해에 도움이 될 수 있습니다.

- An Unsolvable Problem of Elementary Number Theory (Alonzo Church, 1936)

  알론조 처치가 람다 대수를 만들어 결정문제를 해결했던 논문입니다.
  위 튜링의 논문 처럼, 여기서도 괴델의 논문을 언급하고 있습니다.

## 자료 출처

수학 원리의 내용 일부는 [University of Michigan Historical Math Collection][univ-michigan]에서 가져왔습니다.
에니악 사진은 [위키피디아][wp-eniac-source]의 퍼블릭 도메인 이미지에서 가져왔습니다.
문단 간 사진은 [Unsplash][unsplash]의 [Jametlene Reskp][unsplash-jr], [Sebastien Bonneval][unsplash-sb], [Robert Gareth][unsplash-rg]의 사진입니다.

[univ-michigan]: https://quod.lib.umich.edu/u/umhistmath/aat3201.0001.001/35?rgn=full+text;view=pdf;q1=primitive+propositions
[wp-eniac-source]: https://commons.wikimedia.org/wiki/File:Glen_Beck_and_Betty_Snyder_program_the_ENIAC_in_building_328_at_the_Ballistic_Research_Laboratory.jpg
[unsplash]: https://unsplash.com/
[unsplash-jr]: https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EB%B0%94%EB%8B%A5%EC%97%90-%EB%88%84%EC%9B%8C-%EC%9E%88%EB%8A%94-%ED%9D%91%EC%9D%B8%EA%B3%BC-%EB%B0%B1%EC%9D%B8-%EA%B3%A0%EC%96%91%EC%9D%B4-2P11hAY6D9g
[unsplash-sb]: https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EC%9E%A5%EB%82%9C%EA%B0%90-%EA%B1%B4%EB%AC%BC%EC%9D%84-%EB%93%A4%EA%B3%A0-%EC%9E%88%EB%8A%94-%EC%86%90-rRlC4RyHxYw
[unsplash-rg]: https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EB%B0%94%EB%8B%A5%EC%97%90%EC%84%9C-%EC%8A%A4%ED%81%AC%EB%9E%98%EB%B8%94-%EA%B2%8C%EC%9E%84%EC%9D%84-%ED%95%98%EB%8A%94-%EC%97%AC%EC%9E%90-w3SozzL-Ovw
