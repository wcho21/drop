---
title: "간단한 계산기 만들기"
date: 2023-05-12T21:00:00+09:00
summary: "스택을 이용해 만들어보는 계산기"
thumbnail: "./_figs/thumbnail.webp"
---

import AltLang from "@/components/post/AltLang.astro";
import FigureV2 from "@/components/post/FigureV2.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";

import fig1 from "./_figs/fig1.svg";
import fig2 from "./_figs/fig2.svg";
import fig3 from "./_figs/fig3.svg";
import fig4 from "./_figs/fig4.svg";
import fig5 from "./_figs/fig5.svg";



프로그래밍을 배우다보면 `1+2` 같이 두 숫자를 더하는 계산기를 한번쯤 만들어보게 됩니다.
그런데 우리가 흔히 쓰는 프로그래밍 언어는 `1*(2+3)`과 같이 더 복잡한 식을 처리하는데요.

이런 건 어떻게 계산하는 것일까요?
사칙연산으로 확장했을 뿐인데, 두 숫자의 덧셈보다 훨씬 어려운 문제가 됩니다.

이를 구현하는 한 가지 방법으로 스택<AltLang>Stack</AltLang>을 이용해 계산기를 만들 수 있습니다.



# 연산자를 뒤에 쓰기

계산할 식이 `1/(2*3)`이라면, 우린 곱셈을 먼저 합니다.
`(1+2)*3`이라면 덧셈을 먼저 합니다.
이런식으로 괄호는 우선순위를 정합니다.
그런데 이 괄호가 정말 필요할까요?

`2+3` 대신 `23+`을 쓰는 식으로, 연산자를 뒤에 놓아봅시다.
후위 표기식<AltLang>postfix expression</AltLang>이라고 불리는 이것은 복잡해 보일 수 있지만, 곧 만나볼 이유 때문에 계산하기가 쉬워집니다.

문제: `1*(2+3)`은 어떻게 바뀌게 될까요?

답: `1(23+)*`이 됩니다.
그런데 괄호는 필요가 없어 보입니다.
사실 `123+*`라고 고쳐도, 덧셈이 `2`와 `3`을 위한 것이라는 사실은 변하지 않습니다.

## 계산 순서와 똑같은 등장 순서

후위 표기식에서는 연산자들이 계산할 순서대로 나타납니다.
`1*(2+3)`은 곱셈이 먼저 나타나지만, `123+*`은 덧셈이 먼저 나타납니다.
그리고 실제로 우리는 덧셈을 먼저 합니다.

이처럼 후위 표기식은 연산자를 만날때마다 계산하면 됩니다.
그래서 괄호가 따로 필요하지 않고, 따라서 괄호에 있던 내용이 뭐였는지도 기억할 필요가 없습니다.



# 계산기 프로그램 디자인

이런 후위 표기식을 계산하는 계산기를 만들어 봅시다.

그런데 사람은 `1+2` 같은 식, 즉 중위 표기식<AltLang>infix expression</AltLang>을 쓰는 것이 익숙할 텐데요.
따라서 이것을 후위 표기식으로 바꾸는 작업도 필요합니다.

이 모든 작업은 스택만 가지고 처리할 수 있습니다.

정리하면 이 프로그램은 입력을 후위 표기식으로 변환하는 입력 처리 부분과, 실제로 계산을 해내는 계산 부분으로 나뉘는데요.
수도코드로 정리하면 이렇게 됩니다.

```
function evaluateInfix(infix)
  postfix = convertInfixToPostfix(infix)
  evaluated = evaluatePostfix(postfix)
  return evaluated
```

이제 후위 표기식을 계산하는 두 번째 함수 `evaluatePostfix()` 부터 만들어봅시다.



# 계산하기

`12+`를 어떻게 계산할 수 있을까요?
`1`과 `2`를 읽고, `+`를 마주쳤을 때 더하면 될 텐데요. (쉽죠?)

이렇게 숫자를 읽을 때마다 스택에 넣고, 연산자를 만났을 때 숫자를 두 개 꺼내서 계산해봅시다.
계산한 결과는 다시 스택에 넣고요.

정상적으로 진행했다면, 스택에는 하나의 숫자만 남습니다.
이것이 계산 결과가 됩니다.

예를 들어 `12+`로 확인해볼 수 있습니다.

<FigureV2 src={fig1} alt="Calculating postfix expression 12+ with stack">
  <FigureCaption slot="caption">그림 1. 숫자를 스택에 넣고, 더하기 기호를 만났을 때 꺼내서 덧셈 결과인 3을 넣습니다.</FigureCaption>
</FigureV2>

여태까지 숫자<AltLang>number</AltLang>와 연산자<AltLang>operator</AltLang>를 구분해서 불렀는데요.
이제부터 둘 다 토큰<AltLang>token</AltLang>이라고 부르기로 합시다.
그러면 계산기는 토큰을 읽으면서 스택을 조작하는 기계에 불과하게 됩니다.

여기까지의 아이디어를 수도코드로 정리하면 이렇게 됩니다.

```
function evaluatePostfix(postfix)
  stack = new Stack()

  for token in postfix
    if token is a number
      stack.push(token)
    else if token is an operator
      num2 = stack.pop()
      num1 = stack.pop()

      // for example, applyOperator('+', 1, 2) returns 3
      result = applyOperator(token, num1, num2)

      stack.push(result)

  return stack.pop()
```

여기서 `applyOperator()` 함수는 숫자와 연산자를 받아 계산한 결과를 돌려줍니다.

## 구현 예시: 파이썬

예를 들어 파이썬으로 다음과 같이 만들 수 있습니다.
`Stack` 클래스에 `push()`와 `pop()` 메소드가 있다고 합시다.

```python
def evaluatePostfix(postfix):
    stack = Stack()

    for token in postfix:
        if token.isdigit():
            stack.push(int(token))
        elif token in "+-*/":
            num2 = stack.pop()
            num1 = stack.pop()

            evaluated = applyOperator(token, num1, num2)
            stack.push(evaluated)

    return stack.pop()
```

`applyOperator()` 함수는 사칙연산을 돕는 보조 함수입니다.
이 함수가 연산자 토큰에 의미를 붙입니다.

```python
def applyOperator(operator, num1, num2):
  if operator == '+':
    return num1 + num2
  if operator == '-':
    return num1 - num2
  if operator == '*':
    return num1 * num2
  if operator == '/':
    return num1 / num2
```

이제 반이 끝났습니다.



# 입력 변환하기

중위 표기식으로 입력을 받기로 했습니다.
이것을 후위 표기식으로 바꿔야 하는데요.
예를 들어 `1+2`는 `12+`로 고쳐야 합니다.

자세히 보면 후위 표기식으로 바꿀 때, 숫자는 순서가 바뀌지 않는다는 사실을 알 수 있습니다.
그러므로 변환 과정에서는 숫자는 입력받은 대로 출력에 내보내면 됩니다.
다행히 할 일이 줄었네요.

그러면 순서가 바뀌는 것은 연산자 뿐입니다.

여기에 스택을 써봅시다.
숫자는 앞서 말한대로, 읽자마자 출력으로 내보내고요.
연산자는 스택에 넣고, 다 읽었을 때 내보냅시다.

`1+2`를 예로 들면, 원하는 결과인 `12+`를 얻게 됩니다.

<FigureV2 src={fig2} alt="Converting to postfix expression with stack">
  <FigureCaption slot="caption">그림 2. 연산자를 읽을 때마다 스택에 넣고, 식을 끝까지 읽었을 때 꺼냅니다.</FigureCaption>
</FigureV2>

그렇지만 연산자가 더 많으면 어떻게 할까요?



# 급한 기호부터 꺼내기

다른 우선순위를 가진 연산자가 있습니다.
곱셈을 덧셈보다 먼저 하기 때문에, 덧셈 기호 `+`가 우선순위가 더 높다고 볼 수 있습니다.
나눗셈과 뺄셈도 마찬가지 입니다.

이제 스택에 연산자를 두 개 넣는다고 해봅시다.
그러면 경우는 세 가지 뿐인데요.
나중에 오는 연산자의 우선순위가 더 높거나, 더 낮거나, 또는 둘 다 같은 경우입니다.

## 둘 다 우선순위가 같다면

사실 거짓말입니다.

정확히 말하면 우선순위가 같은 경우는 없습니다.
왜냐면 먼저 나타난 연산을 먼저 하니까요.

`1+2-3`을 봅시다.
왼쪽 연산자인 덧셈 기호 `+`가 암묵적으로 더 높은 우선순위를 가집니다.

`1+2` 부분은 앞서 설명한대로 진행해서 스택에 덧셈 기호 `+`를 남기고요.
그 다음 뺄셈 기호 `-`를 마주쳤을 때, 어떻게 처리해야 할까요?

`1+2-3`에서 더하기를 먼저해야 하기 때문에, `+` 기호를 먼저 꺼내서 출력으로 내보내 숫자 `2` 옆에 둬야 합니다.

<FigureV2 src={fig3} alt="Handling operators having the same priority">
  <FigureCaption slot="caption">그림 3. 우선순위가 '같은' 연산자 처리하기. 뺄셈 기호를 만났을 때 덧셈 기호를 꺼냅니다.</FigureCaption>
</FigureV2>

이처럼 덧셈 기호 `+`와 뺄셈 기호 `-`는 먼저온 기호를 더 우선해야 합니다.
마찬가지로 곱셈과 나눗셈 기호도 그렇고요.

얖에서 세 가지 경우로 나눴지만, 지켜야할 원칙은 하나뿐입니다.
먼저 계산할 연산을 먼저 꺼내는 것입니다.

## 나머지 케이스

나머지 두 경우를 생각해보세요.
`1*2+3`인 경우는 어떤가요?
반대로 `1+2*3`인 경우는 어떤가요?
설명이 지루하기 때문에 직접 해보는 부분으로 남겨두겠습니다.

두 번째 경우는 아래 그림처럼 풀어볼 수 있습니다.
덧셈 기호는 꺼내지 않고 그 위에 곱셈 기호를 둡니다.
그래야 다 읽고나서 전부 꺼낼 때 곱셈 기호가 먼저 나오니까요.

<FigureV2 src={fig4} alt="Answer to the second exercise">
  <FigureCaption slot="caption">그림 4. 우선순위가 다른 경우 처리하기. '급한' 기호를 먼저 꺼냅니다.</FigureCaption>
</FigureV2>

## 괄호를 만났을 때

숨겨진 케이스가 마지막으로 하나 더 있었습니다.

다행인 점은, 괄호 안은 기존에 하던 그대로 처리하면 된다는 것입니다.
괄호는 우선순위가 가장 높다는 것, 즉 그 부분부터 처리해야 한다는 것을 의미합니다.
스택에는 가장 최근의 내용이 가장 위에 있기 때문에, 여태 했던 방법에서 바꿀 부분은 없게 됩니다.

그러면 괄호 안의 내용은 신경 쓰지 않고, 괄호 기호만 생각해봅시다.

여는 괄호를 만나면 그대로 스택에 넣고요.
닫는 것을 만나면 여는 괄호까지 꺼내봅시다.
대신 후위 표기식에서 괄호는 없어야 하므로, 모든 괄호는 스택에서 꺼낼 때 버립니다.

예를 들어 `1*(2+3)`를 봅시다.
닫는 괄호를 만나면, 덧셈 기호만 먼저 꺼내 숫자 옆에 붙이게 됩니다.

<FigureV2 src={fig5} alt="Handling parentheses">
  <FigureCaption slot="caption">그림 5. 괄호를 만난 경우 처리하기. 괄호는 출력에 내보내지 않고 버립니다.</FigureCaption>
</FigureV2>

이러면 괄호 안의 식을 먼저 변환합니다.
이는 적절하게 바꿨다는 뜻입니다.
후위 표기식은 연산자가 계산 순서대로 나타나니까요.

이 내용을 수도코드로 정리하면 이렇게 됩니다.

```
function convertInfixIntoPostfix(infix)
  stack = new Stack()
  postfix = new String()

  for token in infix
    if token is a number
      postfix.append(token)
    else if token is an operator
      while precedence(token) > precedence(stack.peek())
        postfix.append(stack.pop())

      stack.push(token)
    else if token == '('
      stack.push(token)
    else if token == ')'
      until '(' appears at the top of stack
        postfix.append(stack.pop())

  until stack is empty
    postfix.append(stack.pop())

  return postfix
```

## 구현 예시: 파이썬

파이썬으로 다음과 같이 구현할 수 있습니다.
`Stack` 클래스에 추가적으로 `peek()`과 `isEmpty()` 메소드가 있다고 합시다.
여기서 `peek()`은 스택에서 가장 위에 있는 것을 꺼내지 않고 리턴합니다.

```python
def convertInfixToPostfix(infix):
    stack = Stack()
    postfix = ""

    for token in infix:
        if token.isdigit():
            postfix += token
        elif token in "+-*/":
            # pop all operators with higher precedence
            while not stack.isEmpty():
                if getPrecedenceOf(stack.peek()) < getPrecedenceOf(token):
                    break
                postfix += stack.pop()

            stack.push(token)
        elif token == '(':
            stack.push(token)
        elif token == ')':
            # pop until an opening parenthesis appears
            while not stack.isEmpty():
                t = stack.pop()
                if t == '(':
                    break
                postfix += t

    while not stack.isEmpty():
        postfix += stack.pop()
    return postfix
```

연산자의 우선순위를 비교할 때 `getPrecedenceOf()` 함수가 보조적으로 필요한데요.

```python
def getPrecedenceOf(token):
    if token in '*/':
        return 2
    if token in '+-':
        return 1
    if token in '(':
        return 0
    raise Exception(f"invalid token '{token}'")
```

여기서 값보다는 상대적인 차이에 의미가 있습니다.
이 함수 덕분에 연산 기호의 우선순위가 정해집니다.

여는 괄호의 우선순위는 가장 낮게 두었는데요.
여는 괄호는 다른 연산자를 만날 때 꺼내면 안되기 때문입니다.



# 계산기 완성하기

이제 만든 함수를 연결해 계산기를 완성합시다.
처음에 디자인했던 계산기 수도코드의 구현이기도 합니다.

```python
def evaluateInfix(infix):
    postfix = convertInfixToPostfix(infix)
    evaluated = evaluatePostfix(postfix)
    return evaluated
```

완성한 프로그램은 [지스트][gist-1]에서 볼 수 있습니다.

[gist-1]: https://gist.github.com/wcho21/e335728564a82e60fb2d2c6e1d09e843


# 마치며

여기까지 간단한 계산기를 만들어 보았습니다.
사실 이것은 다익스트라<AltLang>Edsger Dijkstra</AltLang>의 션팅 야드 알고리즘<AltLang>shunting yard algorithm</AltLang>을 구현한 것입니다.

각 입력 문자는 기껏해야 두 번, 즉 스택에 넣고 뺄 때 처리되는데요.
따라서 시간 복잡도는 입력 문자의 개수 $n$에 대해 $O(n)$이 되는 것을 확인할 수 있습니다.

## 생략한 부분

사실 이 계산기에는 한 자리 수의 숫자밖에 받을 수 없다는 단점이 있습니다.
왜 그럴 수 밖에 없었을까요?
은연중에 숫자와 연산자를 토큰화<AltLang>tokenize</AltLang>하고 있었기 때문입니다.

그러면 어떻게 그럴 수 있었을까요?
문자 하나하나가 그 자체로 의미가 온전했기 때문에 따로 처리가 필요없었던 것입니다.
만약 `12+34`를 처리해야 했다면, `12`는 두 개의 문자이지만 하나의 숫자로 처리해야 했을 것입니다.

여기서는 이러한 토큰화를 생략하는 대신, 한 자리의 숫자만 처리하는 계산기로 만들었습니다.
