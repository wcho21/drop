---
title: "2의 보수"
date: 2024-02-06T14:00:00+09:00
summary: "모듈러 연산으로 알아보는 2의 보수"
thumbnail: "./_figs/thumbnail.webp"
series: "컴퓨터 구조"
---

import AltLang from "@/components/post/AltLang.astro";
import FigureV2 from "@/components/post/FigureV2.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";

import fig1 from "./_figs/fig1.svg";
import fig2 from "./_figs/fig2.svg";



컴퓨터가 숫자를 메모리에 담을 때, 2의 보수<AltLang>two's complement</AltLang>를 이용하는 경우가 있습니다.

구체적으로는 어떤 숫자 $n$의 2의 보수란, 충분히 크도록 선택한 2의 제곱 수 $2^M$에서 $n$을 뺀 수로 정의하는데요.
그런데 여기에는 $2^M$를 $0$으로 취급하겠다는 가정이 암묵적으로 숨어있습니다.
왜냐면 그 수 $2^M$은 오버플로우<AltLang>overflow</AltLang>때문에 $0$으로 표현할 수 밖에 없도록 고를 테니까요.

그렇다면 모듈러 연산<AltLang>modular arithmetic</AltLang>이 이 자리에 알맞게 됩니다.
이 연산은 모듈로<AltLang>module</AltLang>라고 하는 수를 두고, 그 수로 나눈 나머지 같으면 합동<AltLang>congruent</AltLang>인 수, 즉 같은 종류로 취급합니다.

예를 들어, 모듈로가 4라면 1, 5, 9는 나머지가 1로 같으므로 합동이 되고 다음과 같이 표기합니다.

$$
1 \equiv 5 \equiv 9 \mod 4
$$

2의 보수란 $2^M$를 모듈로로 한 것에 불과한데요.
예를 들어 $M=32$로 선택하면 $2^{32}-1$과 $-1$은 $2^{32}$로 나눈 나머지가 같기 때문에 합동이 됩니다.
그래서 32비트 메모리 공간을 가진 C 언어의 `int` 자료형에 $2^{32}-1$을 대입했을 때 `-1`이라는 엉뚱해 보이는 값을 갖게 됩니다.

```c
int a = 4294967295;  // 2^32 - 1
printf("%d", a); // -1
```

그런데 이런 2의 보수를 모듈러 연산으로 바라보면, 부호가 없는 수의 연산도 사실상 똑같은 모듈러 연산 중 하나일 뿐이라는 것을 알게 됩니다.
즉 부호가 있거나 없거나 똑같은 모듈러 연산으로 사칙연산을 할 수 있습니다.
차이는 단지 우리가 이진수를 어떻게 해석하느냐에만 존재하게 되고요.
여기서 '해석'이란 수 많은 합동 수 중에 하나를 고르는 것이 됩니다.



# 비트 표현과 해석

4비트 메모리를 생각해봅시다.
(물론 실제 컴퓨터는 더 많은 비트를 쓰지만요.)
$2^4=16$을 모듈로로 하면, 부호가 있는 수와 없는 수를 똑같은 비트 표현으로 쓸 수 있게 됩니다.

예를 들어 메모리에 `1111`이 들어있다고 해봅시다.
이는 이진수 $1111_{(2)}$로 해석되는데요.
이와 합동인 수는 다음과 같이 일반적으로 $15+16n$이 되고, 실제로는 무한히 많게 됩니다.

$$
\begin{align*}
  1111_{(2)} &\equiv 15 + 16n \\
  &\equiv 15 \equiv 31 \equiv 47 \equiv \cdots \mod 16
\end{align*}
$$

## 해석하기

위 식에서 $n$은 아무 자연수에 해당하기 때문에, $n=0$인 경우, 그대로 숫자 $15$가 합동이라는 걸 알 수 있는데요.

$$
1111_{(2)} \equiv 15 + 0 \equiv 15 \mod 16
$$

보통 `1111`은 부호 없는 수 $15$의 비트 표현이 됩니다.

한편 $n=-1$이라면 $-1$도 합동임을 알 수 있습니다.

$$
1111_{(2)} \equiv 15 - 16 \equiv -1 \mod 16
$$

`1111`은 또한 부호 있는 수 $-1$의 비트 표현이 됩니다.

정리하면 메모리에 있는 값 `1111`은 무한히 많은 합동 수 $15+16n$를 가지는데요.
우리가 부호가 있는 수로 이 비트를 해석할 때는 $n=-1$인 경우를, 부호가 없는 수로 해석할 때는 $n=0$인 경우를 고른다고 볼 수 있습니다.

그리고 이는 다른 비트 표현도 해당됩니다.
네 개의 비트는 16가지 경우를 만들 수 있고, 따라서 우리는 각 16종류의 합동마다 하나의 숫자를 선택할 수 있습니다.
그리고 그런 숫자를 모았을 때, 비트 표현의 해석 규칙이 만들어집니다.

예를 들어, 부호가 없는 수는 앞서 언급한대로 $n=0$ 일 때의 합동 수를 선택하고요.

<FigureV2 src={fig1} alt="unsigned number">
  <FigureCaption slot="caption">그림 1. 부호가 없는 수로 해석하는 비트 표현.</FigureCaption>
</FigureV2>

부호가 있는 수는 가장 왼쪽 비트가 `1`인 비트 표현에 대해 $n=1$ 일 때의 합동 수를 선택합니다.
그러면 가장 왼쪽 비트가 마치 부호를 결정하는 것처럼 생각할 수 있습니다.

<FigureV2 src={fig2} alt="signed number">
  <FigureCaption slot="caption">그림 2. 부호가 있는 수로 해석하는 비트 표현.</FigureCaption>
</FigureV2>



# 모듈러 연산과 오버플로우

이제 프로그래밍에서 숫자를 더한다고 해봅시다.
아까처럼 4비트 메모리 공간을 생각하고요.

예를 들어, 부호가 없는 숫자로서 $8$과 $9$를 더하면 $1$이 될 텐데요.
왜냐면 비트가 네 개인 메모리 공간에서 $2^4=16$은 오버플로우로 인해 버릴 수 밖에 없으니까요.

그런데 모듈러 연산은 이런 오버플로우의 효과가 자연스럽게 나타납니다.

$$
8 + 9 \equiv 1 \mod 2^4
$$

비트 표현을 이진수 그대로 옮기더라도, 모듈러 연산으로 똑같은 사실을 나타낼 수 있습니다.

$$
1000_{(2)} + 1001_{(2)} = 10001_{(2)} \equiv 1_{(2)} \mod 10000_{(2)}
$$

그런데 `1000`과 `1001`은 부호가 있는 수로 생각하면 각각 $-8$, $-7$이 되는데요.
이를 더하면 $-15$ 대신 $1$이 될 것입니다.
앞에서 그렇게 해석하기로 했으니까요.

그리고 이 또한 모듈러 연산이 말해줍니다.

$$
-8 + -7 \equiv 1 \mod 2^4
$$

그리고 이진수 그대로 옮겼을 때도 같은 사실을 말해줍니다.

$$
1000_{(2)} + 1001_{(2)} = 10001_{(2)} \equiv 1_{(2)} \mod 10000_{(2)}
$$

이 식은 부호가 없는 경우와 비교해보면 달라진 부분은 없는데요.
정확히 말하면 그 어떤 식에도 달라진 부분은 없었습니다.
왜냐면 $8 + 9$나 $-8 + -7$은 모듈러 연산에서 같은 것이니까요.

$$
8 + 9 \equiv -8 + -7 \equiv 1 \mod 2^4
$$

이는 비트 표현으로 모듈러 연산을 하는 것과, 비트 표현을 우리가 어떤 숫자로 해석하는지는 별개이기 때문입니다.



# 2의 보수 구하기

원래 주제로 돌아옵시다.
2의 보수라고 하면, 어떤 양수 $n$이 있을 때, 음수 $-n$을 구하는 방법이 많이 소개됩니다.
즉 $n$의 비트 표현에서 `0`과 `1`을 서로 바꾼 다음 `1`을 더하는 것인데요.

다시 메모리 공간이 4비트라고 하고, 숫자 $7$이 주어졌다고 해봅시다.
비트 표현이 `0111`이기 때문에, `1000`에서 `1`을 더해 `1001`로 $-7$의 비트 표현을 구하게 됩니다.

왜 그런걸까요?
이는 모듈러 연산으로 확인할 수 있는데요.
모듈로로 선택한 수, 즉 $2^M \equiv 0$을 이용하면 이를 유도할 수 있습니다.

어떤 수 $n$이 있다고 해봅시다.
그리고 이 수의 비트 표현에서 `0`과 `1`을 서로 바꾼 수를 $\bar{n}$라고 부릅시다.
이는 `111...1`에서 $n$을 뺀 것이고, `1`로 채워진 비트란 곧 $2^M-1$이기 때문에, $\bar{n} = 2^M - n - 1$임을 쉽게 얻을 수 있습니다.

그러면 $-n$를 모듈러 연산으로 다음처럼 구할 수 있습니다.

$$
\begin{align*}
  & \bar{n} = 2^M - 1 - n \equiv -n - 1 \mod 2^M \\
  \therefore \quad & {-n} \equiv \bar{n} + 1 \mod 2^M
\end{align*}
$$

이 식이 말해주는 대로, $-n$은 $n$의 비트 표현에서 `0`과 `1`을 바꾸고 `1`을 더한 것이 됩니다.
즉 2의 보수를 얻는 계산법은 곧 모듈러 연산이 가진 하나의 성질임을 알 수 있습니다.



# 마치며

여기까지 모듈러 연산으로 2의 보수를 구해봤습니다.
그리고 이 연산을 2의 보수 뿐만 아니라, 부호가 없는 수에도 일반적으로 적용할 수 있었습니다.
즉 부호가 있거나 없거나 나머지를 구한다고 생각해보면, 항상 똑같은 방법으로 계산이 가능했습니다.

정수<AltLang>integer</AltLang>를 취급하는 컴퓨터는 이런 정수와 관련된 이론, 즉 정수론<AltLang>number theory</AltLang>과 밀접한 관련이 있을 수 밖에 없는데요.
모듈러 연산은 정수론에서 흔하게 사용되는 연산이기 때문에, 모듈러 연산에 대한 참고 자료는 정수론을 다루는 자료에서 쉽게 찾아볼 수 있습니다.

## 레퍼런스

- _Elementary Number Theory_ (Kenneth H. Rosen, 2011)
