---
title: "2의 보수"
date: 2024-02-06T14:00:00+09:00
summary: "모듈러 연산으로 알아보는 2의 보수"
thumbnail: "./_figs/thumbnail.webp"
---

import L from "@/components/post/AltLang.astro";
import Figure from "@/components/post/FigureV2.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";

import fig1 from "./_figs/fig1.svg";
import fig2 from "./_figs/fig2.svg";



컴퓨터가 숫자를 기억할 때 크게 두 가지 방법이 있습니다.
부호가 있는<L>signed</L> 수와 부호가 없는<L>unsigned</L> 수인데요.
C 언어와 같은 프로그래밍 언어는 이 둘을 데이터 타입으로서 명시적으로 구분합니다.

```c
signed int a = 42; // signed integer
unsigned int b = 42; // unsigned integer
```

컴퓨터는 부호가 있는 수를 위해 2의 보수<L>two's complement</L>를 이용할 수 있습니다.
구체적으로는 어떤 숫자 $n$의 2의 보수란, 충분히 크도록 선택한 2의 제곱 수 $2^M$에서 $n$을 뺀 수로 정의합니다.

그런데 여기에는 $2^M$를 $0$으로 취급하겠다는 가정이 숨어있습니다.
왜냐면 그 수 $2^M$은 정수 오버플로우<L>integer overflow</L>때문에 $0$으로 표현할 수 밖에 없도록 고를 테니까요.

그렇다면 모듈러 연산<L>modular arithmetic</L>이 이 자리에 알맞게 됩니다.
이것은 모듈로<L>module</L>라고 하는 수를 두고, 그 수로 나눈 나머지 같으면 합동<L>congruent</L>인 수, 즉 같은 종류로 취급합니다.
예를 들어 $2^M$을 모듈로로 선택하면, 이를 숫자 $0$과 합동인 수로 보겠다는 뜻입니다.

이렇게 2의 보수를 바라보면, 부호가 없는 수의 연산도 사실상 똑같은 모듈러 연산 중 하나일 뿐이라는 것을 알게 됩니다.
즉 부호가 있거나 없거나 상관없이 똑같은 모듈러 연산으로 사칙연산을 할 수 있습니다.
이 글에서는 어떻게 그렇게 할 수 있는지 그 이유를 알아보겠습니다.



# 나머지 연산

모듈러 연산은 나머지만 생각합니다.
즉 어떤 수를 모듈로라고 정하고, 이것으로 나눈 나머지가 같으면 합동으로 봅니다.
예를 들어, 모듈로가 4라면 1, 5, 9는 나머지가 1로 같으므로 합동입니다.
이런 사실을 다음과 같이 표기합니다.

$$
1 \equiv 5 \equiv 9 \mod 4
$$

양의 정수에서 멈출 필요는 없습니다.
간격이 4만큼 떨어진 모든 음수 또한 합동입니다.

$$
1 \equiv -3 \equiv -7 \mod 4
$$

이렇게 보면, 2의 보수란 $2^M$를 모듈로로 한 것에 불과한데요.
예를 들어 $2^{32}$를 모듈로로 하면 $2^{32}-1$과 $-1$은 합동이 됩니다.

$$
2^{32}-1 \equiv -1 \mod 2^{32}
$$

그래서 많은 프로그래밍 언어에서 $2^{32}-1$이 `-1`이라는 엉뚱해 보이는 값을 갖게 됩니다.
이는 정수 오버플로우라고 불리는 현상인데요.
대표적으로 C 언어의 `int` 자료형이 그렇습니다.
(물론 `int` 자료형이 32비트를 쓴다면요.)

```c
int a = 4294967295;  // 2^32 - 1
printf("%d", a); // -1
```



# 비트 표현과 해석

4비트 메모리를 생각해봅시다.
(물론 실제 컴퓨터는 더 많은 비트를 쓰지만요.)

예를 들어 메모리에 `1111`이 들어있다고 해봅시다.
이는 이진수 $1111_{(2)}$로 해석되는데요.
$2^4=16$을 모듈로로 하면, 이와 합동인 수는 다음과 같이 일반적으로 모든 정수 $n$에 대해 $15+16n$이 됩니다.

$$
1111_{(2)} \equiv 15 + 16n \mod 16
$$

위 식에서 $n=0$인 경우, $15$가 합동이라는 걸 쉽게 알 수 있는데요.

$$
1111_{(2)} \equiv 15 + 0 \equiv 15 \mod 16
$$

한편 $n=-1$이라면 $-1$도 합동임을 알 수 있습니다.

$$
1111_{(2)} \equiv 15 - 16 \equiv -1 \mod 16
$$

그런데 많은 컴퓨터에서 비트 표현 `1111`은, 부호가 없는 수로서 $15$로, 부호가 있는 수로서 $-1$로 해석되는데요.
따라서 $1111_{(2)}$과 합동인 수 중에 하나를, 비트 표현을 해석한 값으로 선택하고 있는 것입니다.

다른 비트 표현도 마찬가지입니다.
네 개의 비트는 16가지 경우를 만들 수 있고, 따라서 우리는 각 16종류의 합동마다 하나의 숫자를 선택할 수 있습니다.
그렇게 숫자를 16개 모았을 때, 비트 표현의 해석 규칙이 만들어집니다.

예를 들어, 부호가 없는 수는 앞서 언급한대로 $n=0$ 일 때의 합동 수를 선택하고요.

<Figure src={fig1} alt="unsigned number">
  <FigureCaption slot="caption">그림 1. 부호가 없는 수로 해석하는 비트 표현.</FigureCaption>
</Figure>

부호가 있는 수는 가장 왼쪽 비트가 `1`인 비트 표현에 대해 $n=1$ 일 때의 합동 수를 선택합니다.
그러면 가장 왼쪽 비트가 마치 부호를 결정하는 것처럼 생각할 수 있습니다.

<Figure src={fig2} alt="signed number">
  <FigureCaption slot="caption">그림 2. 부호가 있는 수로 해석하는 비트 표현.</FigureCaption>
</Figure>

이는 비트 표현 `1000`의 값을, 많은 음수 중에 하필 $-8$로 선택한 이유가 됩니다.



# 모듈러 연산과 오버플로우

이제 프로그래밍에서 숫자를 더한다고 해봅시다.
아까처럼 4비트 메모리 공간을 생각하고요.

예를 들어, 부호가 없는 숫자로서 $8$과 $9$를 더하면 $1$이 될 텐데요.
왜냐면 비트가 네 개인 메모리 공간에서 $2^4=16$은 오버플로우로 인해 버릴 수 밖에 없으니까요.

그런데 모듈러 연산은 이런 오버플로우의 효과가 자연스럽게 나타납니다.

$$
8 + 9 \equiv 1 \mod 2^4
$$

비트 표현을 이진수 그대로 옮기더라도, 모듈러 연산으로 똑같은 사실을 나타낼 수 있습니다.

$$
1000_{(2)} + 1001_{(2)} = 10001_{(2)} \equiv 1_{(2)} \mod 10000_{(2)} \tag{A}
$$

그런데 `1000`과 `1001`은 부호가 있는 수로 생각하면 각각 $-8$, $-7$이 되는데요.
이를 더하면 $-15$ 대신 $1$이 될 것입니다.
앞에서 그렇게 해석하기로 했으니까요.

그리고 이 또한 모듈러 연산이 말해줍니다.

$$
-8 + -7 \equiv 1 \mod 2^4
$$

이진수 그대로 옮겼을 때도 같은 사실을 말해줍니다.

$$
1000_{(2)} + 1001_{(2)} = 10001_{(2)} \equiv 1_{(2)} \mod 10000_{(2)} \tag{A}
$$

방금 얻었던 식 $\textrm{A}$가 다시 나타나는데요.
정확히 말하면 그 어떤 식에도 달라진 부분은 없었습니다.
왜냐면 $8 + 9$나 $-8 + -7$은 모듈러 연산에서 같은 것이니까요.

$$
8 + 9 \equiv -8 + -7 \equiv 1 \mod 2^4
$$

이는 비트 표현으로 모듈러 연산을 하는 것과, 비트 표현을 우리가 어떤 숫자로 해석하는지는 별개이기 때문입니다.



# 2의 보수 구하기

원래 주제로 돌아옵시다.
2의 보수라고 하면, 어떤 양수 $n$이 있을 때, 음수 $-n$을 구하는 방법이 많이 소개됩니다.
즉 $n$의 비트 표현에서 `0`과 `1`을 서로 바꾼 다음 `1`을 더하는 것인데요.

예를 들어, 숫자 $7$에서 음수 $-7$의 비트 표현을 구해야 한다고 해봅시다.
그러면 $7$의 비트 표현이 `0111`이기 때문에, `1000`에서 `1`을 더해 `1001`로 답을 얻게 됩니다.

왜 그런걸까요?
이는 모듈러 연산으로 확인할 수 있는데요.
모듈로로 선택한 수, 즉 $2^M \equiv 0$을 이용하면 이를 유도할 수 있습니다.

어떤 수 $n$이 있다고 해봅시다.
그리고 이 수의 비트 표현에서 `0`과 `1`을 서로 바꾼 수를 $\bar{n}$라고 부릅시다.
이는 `111...1`에서 $n$을 뺀 것이고, `1`로 채워진 비트란 곧 $2^M-1$이기 때문에, $\bar{n} = 2^M - n - 1$이 되는데요.

그러면 $-n$을 모듈러 연산으로 다음처럼 구할 수 있습니다.

$$
\begin{align*}
  & \bar{n} = 2^M - 1 - n \equiv -n - 1 \mod 2^M \\
  \therefore \quad & {-n} \equiv \bar{n} + 1 \mod 2^M
\end{align*}
$$

이 식이 말해주는 대로, $-n$은 $n$의 비트 표현에서 `0`과 `1`을 바꾸고 `1`을 더한 것이 됩니다.
즉 2의 보수를 얻는 계산법은 곧 모듈러 연산이 가진 하나의 성질임을 알 수 있습니다.



# 마치며

여기까지 모듈러 연산으로 2의 보수를 구해봤습니다.
그리고 이 연산을 2의 보수 뿐만 아니라, 부호가 없는 수에도 일반적으로 적용할 수 있었습니다.
즉 부호가 있거나 없거나 나머지를 구한다고 생각해보면, 항상 똑같은 방법으로 계산이 가능했습니다.

정수<L>integer</L>를 취급하는 컴퓨터는 이런 정수와 관련된 이론, 즉 정수론<L>number theory</L>과 밀접한 관련이 있을 수 밖에 없는데요.
모듈러 연산은 정수론에서 흔하게 사용되는 연산이기 때문에, 모듈러 연산에 대한 참고 자료는 정수론을 다루는 자료에서 쉽게 찾아볼 수 있습니다.

## 레퍼런스

- _Elementary Number Theory_ (Kenneth H. Rosen, 2011)
