---
title: "어셈블리 프로그래밍 시작하기"
date: 2025-08-03T01:00:00+09:00
summary: "직접 컴파일해보며 배우는 컴퓨터의 동작"
thumbnail: "/src/assets/thumbnails/2025/08/03/01/thumbnail.webp"
series: "프로그래밍 언어 산책"
---

import L from "@/components/post/AltLang.astro";
import P from "@/components/post/pseudocode";
import Figure from "@/components/post/Figure.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";
import FigureDisplay from "@/components/post/FigureDisplay.astro";
import Quote from "@/components/post/Quote.astro";

import fig1 from "./figs/fig1.jpg";
import fig2 from "@texfigs/2025/08/03/01/fig2.svg";
import fig3 from "@texfigs/2025/08/03/01/fig3.svg";
import fig4 from "@texfigs/2025/08/03/01/fig4.svg";
import fig5 from "@texfigs/2025/08/03/01/fig5.svg";
import fig6 from "@texfigs/2025/08/03/01/fig6.svg";
import fig7 from "@texfigs/2025/08/03/01/fig7.svg";
import fig8 from "@texfigs/2025/08/03/01/fig8.svg";
import fig9 from "@texfigs/2025/08/03/01/fig9.svg";
import fig10 from "@texfigs/2025/08/03/01/fig10.svg";
import fig11 from "@texfigs/2025/08/03/01/fig11.svg";



프로그래밍은 보통 C 언어와 같은 고수준<L>high-level</L> 프로그래밍 언어를 사용하지만, 컴퓨터가 직접 이해할 수 있는 것은 그런 언어가 아닌 기계어<L>machine language</L>입니다.
그러므로 고수준 언어를 기계어로 바꿀 필요가 생기게 되고, 컴파일러가 그 역할을 맡습니다.

대부분의 프로그래밍은 기계어 수준까지 신경 쓸 필요는 없습니다.
하지만 신경 쓸 필요가 없다는 것이 곧 배울 필요가 없다는 말은 아닙니다.
기계어에 가까운 어셈블리어<L>assembly language</L>로 프로그램을 만들어보면 다음과 같은 것을 알 수 있게 됩니다.

- 컴퓨터가 프로그램을 메모리에 올리고 실행하는 과정
- 지역 변수는 빠르고 동적 할당은 느린 이유
- 최적화를 컴파일러에 맡기는 것이 나은 이유

여기서는 어셈블리어를 배우기 위해, 가상의 C 코드를 어셈블리어로 옮겨볼 것입니다.
즉 컴파일러 자체가 되어보는 것입니다.
구체적으로는 다음과 같은 내용을 다룹니다.

- 정수, 배열, 스트링 변수를 만드는 방법
- 조건문과 반복문을 만드는 방법
- 함수를 만드는 방법

어셈블리어에는 변수 타입, 조건문, 반복문, 함수와 같은 개념이 존재하지 않습니다.
따라서 이러한 고수준 언어의 기능을 어떻게 어셈블리어로 만들어낼 수 있는지 보게 될 것입니다.

컴퓨터에서 기계어는 프로세서<L>processor</L>라고 부르는 장치가 해석하고 실행합니다.
따라서 어셈블리어란 이러한 프로세서를 직접적으로 조작하는 것과 같습니다.

<Figure src={fig1} alt="Processor">
  <FigureCaption slot="caption">그림 1. 인텔 사 프로세서. 프로세서는 기계어를 직접 수행하는 장치입니다. 다양한 제조사 덕분에 다양한 프로세서 종류가 존재합니다. -- 사진: [Christian Wiediger][unsplash-cw]</FigureCaption>
</Figure>

[unsplash-cw]: https://unsplash.com/ko/사진/검은색-마더보드의-인텔-프로세서-CKpBhTXvLis

한편, 프로세서는 다양한 종류가 존재하기 때문에 각각 다른 조작 방법을 가집니다.
달리 말하면, 어떤 조작 방법이 정해져 있을 때 그것을 하드웨어로 구현한 것이 프로세서라고 볼 수 있습니다.
이러한 조작 방법은 인스트럭션 세트 아키텍처<L>instruction set architecture</L>, 또는 줄여서 ISA라고 부르거나, 간단히 아키텍처라고도 합니다.
여기에는 인스트럭션을 어떻게 구성할 것인지가 포함됩니다.

앞으로의 내용은 다양한 종류 중에서 RISC-V 어셈블리어로 진행할 것입니다.
명령어가 간단하고 그 개수가 많지 않기 때문에 배우기가 비교적 쉽기 때문입니다.
물론 여기서의 목표는 RISC-V 어셈블리어 자체를 배우는 것이 아니라, 어셈블리어에서 나타나는 일반적인 컨셉을 알아보는 것입니다.

RISC-V 어셈블리어를 배우기 위해 필요한 것은 RISC-V 아키텍처를 가진 컴퓨터입니다.
즉 RISC-V 기계어로 컴파일할 수 있고, 그것을 실행할 수 있어야 합니다.
각각을 위해, RISC-V 아키텍처를 타겟으로 컴파일하는 크로스 컴파일러<L>cross compiler</L>와 RISC-V 가상 머신으로 진행합니다. 
이런 프로그램의 설치 방법은 여기서 다루지 않지만, 본문의 예시 코드가 있는 [깃허브][gh]<L>GitHub</L>의 설명을 참고해볼 수 있습니다.

크로스 컴파일러는 `gcc` 컴파일러를 이용합니다.
다음과 같이 버전을 확인할 수 있다면 설치된 것입니다.

```shellsession
$ riscv64-linux-gnu-gcc --version
riscv64-linux-gnu-gcc (Ubuntu 14.2.0-4ubuntu2) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

가상 머신은 `qemu`를 이용합니다.
이것 또한 다음과 같이 설치를 확인할 수 있습니다.

```shellsession
$ qemu-riscv64 --version
qemu-riscv64 version 9.0.2 (Debian 1:9.0.2+ds-4ubuntu5.3)
Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers
```

프로그래밍 경험이 조금이라도 있고, 조건문과 반복문, 함수가 무엇인지 알고 있다고 가정하고 설명하겠습니다.
C 언어는 예시 코드에 사용하는 언어이므로 아는 것이 내용을 이해하는데 도움이 될 수는 있지만, 필수로 알아야 하는 것은 아닙니다.
그러면 시작해봅시다.



# 첫 프로그램 만들기

먼저 어셈블리어로 프로그램을 만드는 방법을 살펴봅니다.
여기서 소개하는 크로스 컴파일러와 가상 머신의 사용법은 이후 어셈블리어 프로그래밍을 위해 필수적입니다.


## 어셈블러로 실행 파일 만들기

가장 간단한 프로그램으로서, 실행하자마자 끝나는 빈 프로그램을 만들어보겠습니다.
다음 내용을 `empty.S` 파일로 만듭시다.

```asm
  .text
  .align 2

  .global _start
_start:
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

이것의 의미는 잠시 후 설명하기로 하고, 다음과 같이 크로스 컴파일러를 통해 기계어로 바꿔봅시다.

```shellsession
$ riscv64-linux-gnu-gcc -march=rv64g -mabi=lp64d -static -nostdlib empty.S
```

이처럼 어셈블리어를 기계어로 번역하는 프로그램을 어셈블러<L>assembler</L>라고 부릅니다.
여기서는 `a.out` 파일이 실행할 수 있는 프로그램으로 만들어지는데, 이것을 실행 파일<L>executable</L>이라고 부릅니다.

위와 같은 커맨드가 길다면, 다음과 같이 줄일 수도 있습니다.

```shellsession
$ alias gcc="riscv64-linux-gnu-gcc -march=rv64g -mabi=lp64d -static"
$ gcc -nostdlib empty.S
```

앞으로는 이렇게 줄인 것을 사용하겠습니다.

실행 파일을 다음과 같이 실행해봅시다.

```
$ ./a.out
```

마치 실행 파일을 직접 실행한 것 같지만, 다음 커맨드로 보이지 않게 바뀐 것입니다.

```
$ qemu-riscv64 ./a.out
```

즉 RISC-V 가상 머신에서 실행합니다.

프로그램은 실행하자마자 끝납니다.
다음과 같이 종료 코드<L>exit code</L>를 확인해봅시다.

```
$ echo $?
0
```

이 값은 다음 줄에서 온 것입니다.

```
  li a0, 0
```

정말일까요?
이 줄을 바꿔서 실행해보세요.
예를 들어, `0`을 `1`로 바꿔보는 것입니다.
그리고 종료 코드를 확인해보세요.

## 소스 코드 훑어보기

작성했던 코드의 의미를 간략하게 살펴보겠습니다.

다음과 같이 점으로 시작하는 것들은 어셈블러에 대한 명령입니다.

[gnu-as-directive]: https://sourceware.org/binutils/docs/as/Pseudo-Ops.html

```asm
  .text
  .align 2
```

[매뉴얼][gnu-as-directive]에 따르면 이것은 어셈블러 지시자<L>directive</L>라고 부릅니다.
여기서 `.text`는 다음에 올 것들이 프로세서에 대한 명령, 즉 인스트럭션이라고 어셈블러에게 알려줍니다.
더 자세한 의미는 나중에 볼 것입니다.

모든 프로그램에는 엔트리 포인트<L>entry point</L>라고 부르는 시작점이 존재합니다.
그 이름은 기본적으로 `_start`로 정해져 있으므로, 다음 부분은 엔트리 포인트를 나타내는 것입니다.

```asm
  .global _start
_start:
```

따라서 그 다음에는 처음으로 실행할 인스트럭션이 옵니다.

```asm
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

첫 줄은 코멘트에 해당합니다.
어셈블리어는 의미를 바로 파악하기가 쉽지 않기 때문에, 코드의 역할을 나타내기 위해 코멘트를 자주 활용할 것입니다.

`li` 인스트럭션은 레지스터에 값을 넣습니다.
여기서 레지스터<L>register</L>란 프로세서의 기억 공간이고 각각 정해진 이름을 갖고 있습니다.
즉 두 번째 줄은 `a0` 레지스터에 `0`을 넣는 것입니다.

`ecall` 인스트럭션은 시스템 콜<L>system call</L>을 호출합니다.
시스템 콜은 운영 체제가 제공하는 기본적인 함수입니다.
이때 `a7` 레지스터에는 호출하려는 시스템 콜의 번호를 전달합니다.
리눅스 커널의 [소스 코드][unistd-h-exit]에 따르면, `exit()` 시스템 콜에 해당하는 번호는 `93`입니다.
따라서 `exit()` 시스템 콜을 호출하는 코드입니다.

[unistd-h-exit]: https://github.com/torvalds/linux/blob/v6.13/include/uapi/asm-generic/unistd.h#L258

이 시스템 콜은 프로그램을 종료하며, [매뉴얼][man-exit]에 따르면 다음과 같은 프로토타입을 가집니다.

```c
void _exit(int status);
```

즉 첫 번째 인자로 종료 코드를 받습니다.
여기서 첫 번째 인자는 `a0` 레지스터로 전달합니다.
따라서 프로그램을 실행하면 종료 코드 `0`을 리턴하게 됩니다.

## 인사 메시지 보여주기

이제 빈 프로그램 대신 뭔가 하는 것을 만들어봅시다.
인사 메시지를 보여주는 프로그램을 `hello.S` 파일로 만들어보겠습니다.

먼저, 다음과 같이 스트링을 만듭니다.

```asm
  .data
msg:
  .asciz "Hello, world!\n"
  .set len, . - msg
```

첫 줄의 `.data` 지시자는 다음에 데이터가 온다고 어셈블러에게 알려줍니다.
앞서 `.text` 지시자와 비슷한 역할을 맡는데, 이런 것을 섹션<L>section</L>이라고 부릅니다.
이것이 중요한 이유는 프로그램을 만들 때 데이터와 인스트럭션을 메모리 상에서 구분하여 배치하기 때문입니다.
이에 대한 자세한 내용은 곧 만날 것입니다.

그 다음, 콜론으로 끝나는 `msg:`와 같은 것은 레이블<L>label</L>이라고 부릅니다.
어셈블러는 이런 레이블을 만나면, 그 이름에 해당하는 주소 값으로 대체합니다.
그리고 `.asciz` 지시자는 널 문자로 끝나는 스트링이라고 알려줍니다.

마지막에 `.set` 지시자는 상수를 만들어서 어셈블러에게 알려줍니다.
즉 어셈블러가 `len`을 만나면 상수 값으로 대체하도록 만듭니다.
`len`의 값은 앞서 만든 스트링의 길이가 되는데, 그 이유는 나중에 볼 것입니다.

위 코드에 이어서, 다음과 같이 엔트리 포인트를 작성합니다.

```asm
  .text
  .align 2

  .global _start
_start:
```

이 부분은 계속해서 사용할 것이므로, 앞으로는 단순히 엔트리 포인트라고만 언급하고 구현 코드를 생략하겠습니다.

이어서 다음과 같이 작성합니다.

```asm
  /* write(stdout, msg, len) */
  li a0, 1
  la a1, msg
  li a2, len
  li a7, 64
  ecall
```

이 부분은 `msg` 레이블의 스트링을 화면에 보여줍니다.

앞서 소개한 것처럼, `ecall`은 시스템 콜을 호출합니다.
쓰기 작업을 하는 `write()` 시스템 콜은 `64`번에 해당하는데, 이 번호가 `a7` 레지스터에 들어갔습니다.

[매뉴얼][man-write]에 따르면 이 시스템 콜의 프로토타입은 다음과 같습니다.

```c
ssize_t write(int fd, const void buf[.count], size_t count);
```

이것은 인자를 세 개 받습니다.

시스템 콜의 인자는 첫 번째부터 차례로 `a0`, `a1`, `a2` 레지스터에 들어갑니다.
각각의 의미는 위 프로토타입과 같습니다.
즉, `a0`에는 파일 디스크립터 `1`을 넘깁니다.
이것은 표준 출력이므로, 화면에 나타나게 됩니다.
`a1`과 `a2`에는 각각 스트링 주소와 그 길이를 넘깁니다.
여기서 `a1`에는 `la` 인스트럭션이 쓰였는데, 이것은 'Load Adress'로서 주소를 가져옵니다.

마지막으로, 프로그램을 종료하는 코드를 작성합니다.

```asm
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

실행 파일을 만들고 실행하면, 다음과 같이 셸에 인사 메시지가 나타납니다.

```shellsession
$ gcc -nostdlib hello.S
$ ./a.out
Hello, world!
```

한번 `msg` 레이블의 스트링을 수정해서 실행해보세요.
예를 들면 다른 인사말로 바꿔보는 것입니다.



# 어셈블리어부터 실행까지의 과정

지금까지 작성한 코드가 어떻게 기계어로 만들어지고 실행되는지 자세히 살펴보겠습니다.
이를 통해 왜 앞서 어셈블리어를 그런 식으로 작성했는지 알게 됩니다.

물론 기계어를 직접 읽는 것은 어렵기 때문에, 어셈블리어로 다시 복원할 것입니다.
기계어에서 반대로 어셈블리어로 번역하는 것을 디스어셈블링<L>disassembling</L>이라고 부릅니다.
이것은 컴파일러에 내장된 기능이기 때문에 곧바로 해볼 수 있습니다.

## 어셈블링: 오브젝트 파일 만들기

앞서 어셈블리어를 바로 실행 파일로 옮겼지만, 내부적으로는 좀더 세분화된 단계가 있습니다.
첫 번째로 거치는 과정은 어셈블링<L>assemble</L>이라고 부르며, 다음과 같이 `-c` 옵션으로 실행합니다.

```shellsession
$ gcc -nostdlib -c hello.S
```

이 커맨드가 만드는 `hello.o` 파일은 오브젝트<L>object</L> 파일이라고 부릅니다.
온전한 실행 파일은 아니지만, 부분적으로 완성된 실행 파일처럼 생각해볼 수 있습니다.
이 파일은 실행 파일을 만들 때 사용됩니다.

## `text` 섹션 디스어셈블링

이 파일에 어떤 섹션이 있는지 확인해봅시다.

```shellsession
$ riscv64-linux-gnu-objdump -h hello.o
```

여기서는 다음과 같이 줄여서 쓰겠습니다.

```shellsession
$ alias objdump=riscv64-linux-gnu-objdump
$ objdump -h hello.o
```

그 결과 중 일부분은 다음과 같습니다.

```shellsession
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000024  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000f  0000000000000000  0000000000000000  00000064  2**0
                  CONTENTS, ALLOC, LOAD, DATA
```

`text`와 `data` 섹션이 들어있습니다.

이것이 과연 앞서 작성했던 것일까요?
아니면 이름만 우연히 같고 내용은 다른 것일까요?
`text` 섹션에 무엇이 들어있는지 디스어셈블 해보겠습니다.

```shellsession
$ objdump -d -j .text hello.o
```

결과는 다음과 같습니다.

```shellsession
0000000000000000 <_start>:
   0:   00100513                li      a0,1
   4:   00000597                auipc   a1,0x0
   8:   0005b583                ld      a1,0(a1) # 4 <_start+0x4>
   c:   00f00613                li      a2,15
  10:   04000893                li      a7,64
  14:   00000073                ecall
  18:   00000513                li      a0,0
  1c:   05d00893                li      a7,93
  20:   00000073                ecall
```

왼쪽에는 주소와 함께 기계어가, 오른쪽에는 어셈블리어가 나타납니다.
그리고 실제로 작성했던 코드와 거의 일치합니다.
두 번째와 세 번째 줄, 즉 `aupic`와 `ld` 인스트럭션은 다른 부분인데, 실제로 작성했던 코드는 `li` 인스트럭션이었습니다.

```asm
  li a1, msg
```

사실 `li` 명령은 프로세서가 이해할 수 있는 '진짜' 인스트럭션은 아닙니다.
다만 편의를 위해 짧게 줄인 것을 어셈블리어 차원에서 제공한 것입니다.
이를 수도 인스트럭션<L>pseudo-instruction</L>이라고 부릅니다.

RISC-V 어셈블리어는 이것 말고도 다른 수도 인스트럭션을 꽤 많이 갖고 있습니다.
여기서는 필요한 경우가 아니라면 이 두 가지를 굳이 구분하지 않고 사용합니다.

## `data` 섹션 디스어셈블링

비슷한 방법으로 `data` 섹션의 내용도 볼 수 있습니다.

```shellsession
$ objdump -d -j .data hello.o
```

결과는 다음과 같습니다.

```shellsession
0000000000000000 <msg>:
   0:   6c6c6548                .word   0x6c6c6548
   4:   77202c6f                .word   0x77202c6f
   8:   646c726f                .word   0x646c726f
   c:   0a21                    .short  0x0a21
        ...
```

여기서 첫 번째 줄의 `6c6c6548`에 주목해봅시다.
이것은 네 개의 바이트<L>byte</L>를 차지하는 값이고, `48`, `65`, `6c`, `6c`가 차례로 기록된 것입니다.
이렇게 바이트가 역순으로 나타난 이유는 RISC-V 아키텍처가 리틀 엔디안<L>little-endian</L>을 따르기 때문입니다.

이 부분을 이해하려면, 먼저 값<L>value</L>과 표현<L>representation</L>은 분리되어 있다는 사실부터 설명해야 합니다.
즉 숫자로서의 값 $42$은 메모리 상에서 표현된 것과 무관한 것입니다.
값을 정확하게 기록할 수 있다면, 메모리 상에서 어떤 표현을 갖든지 상관이 없기 때문입니다.

반대로 말하면, 메모리에 `1001`라는 표현이 들어있다고 해서, 이것이 바로 이진수 $1001_{(2)}$에 해당하는 값인지는 알 수 없다는 뜻입니다.
예를 들어, 2의 보수에 따르면 이 값은 $-7$을 나타낼 수도 있습니다.
즉 표현 자체는 값과 무관하며, 그것을 읽는 방법이 값을 결정합니다.

한편, RISC-V 아키텍처에서 메모리는 바이트마다 순번이 매겨져있다고 가정합니다.
즉 바이트를 메모리의 최소 단위로 보는 것입니다.
이러한 메모리를 바이트 어드레서블<L>byte addressable</L>하다고 부릅니다.
(다른 여러 아키텍처 또한 이러한 메모리를 다룹니다.)

그리고 RISC-V에서는 4 바이트를 워드<L>word</L>라고도 부릅니다.
(다른 여러 아키텍처도 그렇습니다.)
리틀 엔디안은 어떤 표현이 있을 때, 가장 오른쪽 바이트부터 낮은 메모리 주소에 두는 방식입니다.
예를 들어, `12345678` 라는 표현을 메모리 주소 `0`번에 둬야한다고 해봅시다.
그러면 오른쪽 `78`부터 두기 때문에, 메모리에는 `0`번부터 `3`번까지 차례로 `78`, `56`, `34`, `12`가 기록됩니다.

<Figure src={fig2} alt="little endian of the representation 12345678">
  <FigureCaption slot="caption">그림 2. 리틀 엔디안으로 기록된 `12345678`. 이 표현은 네 개의 바이트로서 `12`, `34`, `56`, `78`로 나뉘고, 가장 오른쪽부터 낮은 메모리 주소에 옵니다.</FigureCaption>
</Figure>

RISC-V 아키텍처는 리틀 엔디안을 따르기 때문에, 앞서 첫 번째 줄의 `6c6c6548`은 차례로 `48`, `65`, `6c`, `6c`를 기록한 것입니다.
여기서 문자 값을 얻기 위해 아스키<L>ASCII</L> 코드로 변환해보면, 앞서 입력했던 스트링이 그대로 나타납니다.

<Figure src={fig3} alt="little endian of the string">
  <FigureCaption slot="caption">그림 3. 메모리에 기록된 스트링. 앞서 입력한 스트링이 나타납니다.</FigureCaption>
</Figure>

한편, 앞서 `text` 섹션에서 다음 네 번째 인스트럭션을 주목해봅시다.

```shellsession
   c:   01200613                li      a2,15
```

이것은 원래 소스 코드에서 다음과 같았습니다.

```asm
  li a2, len
```

즉 어셈블러가 `len` 상수를 `15`로 계산한 것입니다.
이 상수는 다음과 같이 만들었습니다.

```asm
msg:
  .asciz "Hello, world!\n"
  .set len, . - msg
```

넘어갔던 설명을 해보자면, 점 기호 `.`은 현재 주소를 의미합니다.
그런데 `msg` 레이블의 스트링을 위해 15 바이트를 할당했기 때문에, 주소 `.`은 상대적으로 그만큼 큰 값이 됩니다.
따라서 `len`은 그 주소의 차이로서, 자연스럽게 문자열의 길이가 됩니다.

## 링킹: 실행 파일 만들기

앞서 디스어셈블링 결과에서는 각 섹션이 메모리 주소 `0`번 부터 시작하는데, 정확한 주소가 결정되지 않았다는 의미입니다.
나중에 실행 파일을 만드는 과정에서 구체적인 주소로 정해집니다.
이것을 리로케이션<L>relocation</L>이라고 부릅니다.

오브젝트 파일에는 리로케이션의 대상이 들어있습니다.
다음과 같이 확인할 수 있습니다.

```shellsession
$ objdump -r hello.o
```

결과 중 일부를 보면 `msg` 레이블을 포함하고 있습니다.

```shellsession
RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000004 R_RISCV_GOT_HI20  msg
```

오브젝트 파일에서 실행 파일을 만드는 과정을 링킹<L>linking</L>이라고 부르고, 그 역할을 맡는 프로그램을 링커<L>linker</L>라고 부릅니다.
다음과 같이 링커로 실행 파일을 만듭시다.

```shellsession
$ riscv64-linux-gnu-ld hello.o
```

앞서 `gcc`로 실행 파일을 바로 만들었는데, 어셈블링과 링킹을 한번에 거친 것과 같습니다.
각 단계를 따로 거치더라도, 실행 파일은 똑같은 결과를 보여줍니다.

```shellsession
$ ./a.out
Hello, world!
```

실행 파일에서 `text` 섹션의 메모리 주소는 어떨까요?
디스어셈블 해봅시다.

```shellsession
$ objdump -d -j .text --no-show-raw-insn a.out
```

그러면 다음과 비슷한 결과가 나타날 것입니다.

```shellsession
0000000000010120 <_start>:
   10120:       li      a0,1
   10124:       auipc   a1,0x2
   10128:       ld      a1,-316(a1) # 11fe8 <_GLOBAL_OFFSET_TABLE_+0x8>
   1012c:       li      a2,15
   10130:       li      a7,64
   10134:       ecall
   10138:       li      a0,0
   1013c:       li      a7,93
   10140:       ecall
```

엔트리 포인트가 구체적인 주소로 특정되었습니다.
이와 같이 `data` 섹션도 확인해보시기 바랍니다.

섹션의 시작 주소는 이런 방법으로도 볼 수 있습니다.

```shellsession
$ objdump -h a.out
```

결과는 다음과 비슷할 것입니다.
여기서 메모리 주소인 `VMA` 항목에 주목해보시기 바랍니다.

```shellsession
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000024  0000000000010120  0000000000010120  00000120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .got          00000010  0000000000011fe0  0000000000011fe0  00000fe0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .got.plt      00000010  0000000000011ff0  0000000000011ff0  00000ff0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         0000000f  0000000000012000  0000000000012000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
```

`text` 섹션과 `data` 섹션이 메모리 상 구분되어 있습니다.

실행 파일을 실행하면, 로더<L>loader</L>라는 프로그램은 각 섹션을 메모리에 올립니다.

<Figure src={fig4} alt="memory layout with sections">
  <FigureCaption slot="caption">그림 4. 메모리 레이아웃 상 각 섹션의 위치. 각 시작 주소는 링커가 배치한 결과입니다.</FigureCaption>
</Figure>

이 작업을 위해, 실행 파일에는 로더가 참고할 메타 데이터를 포함하고 있어야 합니다.
리눅스에서 사용하는 대표적인 실행 파일 형태는 ELF 파일입니다.
`readelf` 프로그램으로 메타 데이터를 살펴볼 수 있습니다.

```shellsession
$ riscv64-linux-gnu-readelf -h a.out
```

일부 결과를 가져오면 다음과 같습니다.

```shellsession
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           RISC-V
  Version:                           0x1
  Entry point address:               0x10120
```

엔트리 포인트 주소를 비롯해 다양한 정보가 나타납니다.
로더는 이 정보를 이용해 프로그램을 메모리에 옮기고, 엔트리 포인트부터 명령을 실행하게 됩니다.

## 프로그램 실행 과정

메모리에 올라온 후, 프로그램은 구체적으로 어떻게 실행될까요?

다음에 수행할 인스트럭션의 주소는 프로그램 카운터라고 부르는 레지스터가 기억합니다.
RISC-V 아키텍처에는 `pc` 레지스터가 그 역할을 맡습니다.

결론적으로, 컴퓨터가 하는 일은 다음 과정을 단순히 반복하는 것입니다.

1. 프로그램 카운터의 값을 가져온다.
1. 그 주소로 인스트럭션을 가져온다.
1. 그 인스트럭션을 실행한다.
1. 프로그램 카운터의 값을 증가시킨다.

<Figure src={fig5} alt="program execution with program counter diagram">
  <FigureCaption slot="caption">그림 5. 프로그램 실행 과정. 프로그램 카운터의 값이 `10120`일 때, 이 주소로 메모리에서 인스트럭션을 가져옵니다. 프로세서는 그 인스트럭션을 실행하고, 프로그램 카운터의 값을 4 만큼 더합니다. 이 과정을 반복하면, 프로그램 전체가 실행됩니다.</FigureCaption>
</Figure>

예를 들어, 앞서 디스어셈블한 결과를 다시 가져와봅시다.

```shellsession
0000000000010120 <_start>:
   10120:       li      a0,1
   10124:       auipc   a1,0x2
   10128:       ld      a1,-316(a1) # 11fe8 <_GLOBAL_OFFSET_TABLE_+0x8>
   1012c:       li      a2,15
   10130:       li      a7,64
   10134:       ecall
   10138:       li      a0,0
   1013c:       li      a7,93
   10140:       ecall
```

RISC-V 아키텍처는 인스트럭션이 4 바이트이므로, `pc` 레지스터의 값 또한 `4`씩 증가하게 됩니다.
따라서 프로그램 카운터는 엔트리 포인트의 주소인 `10120`부터 시작해, 프로세서는 각 인스트럭션을 순차적으로 실행하게 됩니다.



# 변수 구현하기

C 언어는 아키텍처와 무관하게 쓸 수 있는 고수준 언어인 반면, 어셈블리어는 그렇지 않습니다.
하지만 프로세서가 이해하는 것은 C 언어가 아닌 기계어이므로, 컴파일러는 C 코드를 어셈블리어로 컴파일하게 됩니다.

그 과정을 손수 따라해보며, 어떻게 어셈블리어가 고수준 언어의 기능을 만들어내는지 살펴보겠습니다.
그 첫 단계로서, 다음과 같은 전역 `int` 변수를 만드는 것이 목표입니다.

```c
int foo = 42;
```

여기서 `int` 타입은 4 바이트라고 가정하겠습니다.

## 초기화

변수는 메모리 공간의 할당입니다.
따라서 `data` 섹션에서 메모리를 할당하여 `int` 변수를 만들 수 있습니다.

```asm
  .data
foo:
  .word 42
```

`.word` 지시자는 워드의 크기인 4 바이트만큼 메모리를 차지하도록 만듭니다.

결과를 보기 위해, 종료 코드를 변수의 값으로 리턴해봅시다.
위 코드에 이어서, `text` 섹션에 엔트리 포인트를 직접 만들어보시기 바랍니다.
그 아래에 코드를 작성합니다.

```asm럼
_start:
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

`lw` 인스트럭션은 'Load Word'로서, `a0` 레지스터에 `foo` 값을 워드 크기로 가져와 넣습니다.
그리고 `exit()` 시스템 콜을 호출합니다.

실행하면 종료 코드는 다음과 같이 `42`가 됩니다.

```shellsession
$ gcc -nostdlib int.S
$ ./a.out
$ echo $?
42
```

한번 `foo` 변수의 값을 바꿔서, 종료 코드가 바뀌는지 확인해보세요.

## 실제 컴파일과 비교하기

정말로 컴파일러가 변수를 이런 식으로 컴파일할까요?
C 언어로 작성해서 컴파일 결과를 살펴보겠습니다.
다음을 `int_c.c` 파일로 만들어봅시다.

```c
int foo = 42;

int main(void) {
  return 0;
}
```

이것을 컴파일합니다.
여기서 컴파일이란 C 언어를 어셈블리로 옮기는 과정을 말합니다.

```shellsession
$ gcc -nostdlib -S -O0 int_c.c
```

그러면 `int_c.s` 어셈블리 파일이 만들어집니다.
열어보면 다음과 같은 것을 찾을 수 있습니다.

```asm
foo:
  .word 42
```

이것은 직접 작성했던 어셈블리어와 같습니다.



# 다른 정수 타입 구현하기

다른 크기의 정수 타입도 만들어보겠습니다.
다음과 같은 코드가 목표입니다.

```c
char foo = 42;
short bar = 99;
long baz = 1;
```

또한 종료 코드로 결과를 확인하는 것 대신, C 언어 라이브러리인 `printf()` 함수를 이용할 것입니다.
따라서 C 언어와 어셈블리를 함께 쓰는 방법도 알아볼 것입니다.

이어서, 다른 메모리 크기를 사용했을 때 발생하는 문제도 해결해볼 것입니다.
이를 통해 앞서 사용한 `.align` 지시자가 왜 필요한지 알게 됩니다.

## C 언어와 연동

C 언어에서 `char` 타입은 1 바이트입니다.
여기서 `short` 타입과 `long` 타입이 각각 2 바이트와 8 바이트라고 해봅시다.
다음을 `types.S` 파일로 만들어봅시다.

```asm
  .data
baz:
  .dword 1
bar:
  .half 99
foo:
  .byte 42
```

[매뉴얼][gnu-as-riscv]에 따르면, RISC-V 어셈블리어에서 `.dword`, `.half`, `.byte` 지시자는 각각 8, 2, 1 바이트에 해당합니다.

[gnu-as-riscv]: https://sourceware.org/binutils/docs/as/RISC_002dV_002dDirectives.html 

변수의 값을 `printf()` 함수로 프린트할 것입니다.
따라서 C 코드가 변수의 이름을 알 필요가 있습니다.
위 코드에 이어서 다음 줄을 추가합니다.

```asm
  .global baz
  .global bar
  .global foo
```

변수의 값을 프린트할 차례입니다.
`types.c` 파일을 만들어봅시다.

```c
#include <stdio.h>

extern char foo;
extern short bar;
extern long baz;

int main(void) {
  printf("foo: %d, bar: %hd, baz: %ld\n", foo, bar, baz);
  return 0;
}
```

여기서 `extern` 키워드는 다른 파일에서 정의한 변수라고 컴파일러에게 알려줍니다.

다음과 같이 컴파일합니다.

```shellsession
$ gcc types.c types.S
```

실행하면 다음과 같습니다.

```shellsession
$ ./a.out
foo: 42, bar: 99, baz: 1
```

한번 `char` 타입으로 선언했던 변수를 `long` 타입으로 바꿔서 사용해보세요.
그렇게 해도 문제가 없을까요?

물론 문제가 생길 수도 있습니다.
하지만 어셈블리어에는 기본적으로 타입이라는 개념이 없으므로, 그러한 동작을 막지 않습니다.
즉, 어셈블리어는 타입을 관리할 책임이 프로그래머에게 있습니다.

## 메모리 얼라인먼트

방금의 코드에서는 가장 큰 메모리 크기부터 할당한 이유가 있습니다.
그 이유를 알아보기 위해, 이번에는 반대로 작성해보겠습니다.

```asm
  .data
foo:
  .byte 42
bar:
  .half 99
baz:
  .dword 1
```

오브젝트 파일을 만들어봅시다.

```shellsession
$ gcc -nostdlib types.S -c
```

그리고 `data` 섹션을 디스어셈블 해봅시다.

```shellsession
$ objdump -d -j .data --no-show-raw-insn types.o
```

결과에서 메모리 주소를 주목해보세요.

```shellsession
0000000000000000 <foo>:
   0:   .word   0x0100632a

0000000000000001 <bar>:
   1:   .word   0x00010063

0000000000000003 <baz>:
   3:   .word   0x00000001
   7:   .word   0x00000000
```

`bar`와 `baz` 변수의 메모리 주소는 홀수가 됩니다.

어셈블리어에서 데이터의 주소를 홀수로 두는 것은 좋지 않습니다.
아키텍처에 따라 그런 데이터의 접근을 지원하지 않을 수도 있고, 지원하더라도 성능 상 불이익이 나타납니다.
[매뉴얼][riscv-isa-man]에 따르면, RISC-V 아키텍처에서도 지원은 보장되지 않습니다.
이러한 한계는 여기서 자세히 다루지는 않겠지만 하드웨어 구현 상 어려움에서 옵니다.

다른 여러 아키텍처와 마찬가지로, RISC-V 아키텍처의 [매뉴얼][riscv-prog-man]에서 권고하는 것은 '읽기 좋은' 메모리 주소에 두는 것입니다.
예를 들어 2 바이트의 크기라면, 주소를 2 바이트의 배수로 맞추는 것을 의미합니다.
이처럼 데이터가 $n$ 바이트일 때, $n$ 바이트의 배수인 주소를 그 데이터의 내츄럴 바운더리<L>natural boundary</L>라고 부릅니다.
그리고 그 주소로 맞추는 것을 얼라인<L>align</L>한다고 부릅니다.


`.align` 지시자를 이용해 올바른 코드로 고쳐보겠습니다.

```asm
  .data
foo:
  .byte 42
  # [!code ++:1]
  .align 1
bar:
  .half 99
  # [!code ++:1]
  .align 3
baz:
  .dword 1
```

여기서 `.align` 지시자에 숫자 $n$이 오면, $2^n$ 바이트로 얼라인한다는 점을 참고하세요.
즉 `bar` 레이블의 주소는 2 바이트로, `baz`는 8 바이트로 얼라인합니다.

이렇게 수정한 코드를 마찬가지로 디스어셈블 해서 각 변수가 어디에 위치하는지 확인해보세요.

한편, 앞서 `data` 섹션에서도 이러한 지시자를 사용했습니다.

```asm
  .text
  .align 2
```

이렇게 인스트럭션을 얼라인하는 것은 RISC-V 아키텍처의 요구 사항입니다.



# 덧셈 구현하기

변수를 구현했으니, 다음과 같은 덧셈을 만들어봅시다.

```c
int foo = 42;

int main(void) {
  return foo + 99;
}
```

RISC-V 아키텍처에는 덧셈 인스트럭션이 있기 때문에 바로 만들 수 있습니다.

## 어셈블리어로 옮기기

앞서 `int.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`add.S` 파일을 만들어서 엔트리 포인트를 작성합니다.

```asm
_start:
  /* exit(foo + 99) */
  lw a0, foo
  addiw a0, a0, 99
  li a7, 93
  ecall
```

`lw` 인스트럭션으로 `foo` 값을 가져오고, `addiw` 인스트럭션으로 `99`를 더합니다.
덧셈 결과인 `141`는 곧 종료 코드가 됩니다. (확인해보세요.)

## 인스트럭션 디코딩

프로세서는 인스트럭션을 실행한다고 했습니다.
여기서는 `addiw` 인스트럭션을 예로 들어서 그 과정을 살펴보겠습니다.
이를 통해 RISC-V 기계어가 어떻게 구성되는지 알게 될 것입니다.

먼저, 모든 RISC-V 인스트럭션은 크기가 32 비트이고, 인스트럭션의 종류를 알려주는 opcode 필드를 가장 오른쪽 7 비트에 가집니다.
`addiw` 인스트럭션은 다음 형태를 갖고 있습니다.

<Figure src={fig6} alt="addiw instruction fields">
  <FigureCaption slot="caption">그림 6. `addiw` 인스트럭션의 필드. 32 비트가 다섯 개의 필드로 구성됩니다.</FigureCaption>
</Figure>

여기서 3 비트의 funct3 필드는 opcode 필드과 함께 인스트럭션의 종류를 나타냅니다.
즉 프로세서는 이 두 필드를 읽어서 `addiw` 인스트럭션이라는 것을 알게됩니다.

남은 22 비트 중에 5 비트의 rd 필드는 결과가 담길 레지스터를 가리킵니다.
레지스터가 5 비트로 표현되기 때문에, 총 32 개의 레지스터를 가리킬 수 있게 됩니다.
실제로 RISC-V 아키텍처는 32 개의 레지스터를 갖습니다.

rs1 필드는 덧셈할 값이 담긴 레지스터를 가리킵니다.
마지막으로 남은 immediate 필드에는 더할 값이 담깁니다.
이렇게 명령어에 직접 담긴 값을 이미디에이트<L>immediate</L> 값이라고 부릅니다.

원래의 인스트럭션은 다음과 같습니다.

```asm
  addiw a0, a0, 99
```

여기서 `a0` 레지스터가 10 번 레지스터에 해당한다는 사실을 이용하면, 이것이 기계어로 어떻게 바뀔지 예상해볼 수 있습니다.
10은 2진법으로 `1010`, 99는 `1100011`이므로, 모든 필드를 구하게 됩니다.

<Figure src={fig7} alt="hex value of a specific addiw instruction">
  <FigureCaption slot="caption">그림 7. `addiw a0, a0, 99` 인스트럭션의 필드. 전체 비트를 16진법으로 바꾸면 `0635051b`가 됩니다.</FigureCaption>
</Figure>

이 인스트럭션을 16진법으로 표현하면 `0635051b`가 됩니다.

디스어셈블링을 통해 확인해봅시다.

```shellsession
$ gcc -nostdlib -c add.S
$ objdump -d -j .text add.o
```

결과 중에 다음이 나타날 것입니다.

```shellsession
   8:   0635051b                addiw   a0,a0,99
```

왼쪽의 기계어가 예상했던 16진법 결과와 일치합니다.

## 뺄셈

그렇다면 뺄셈은 어떻게 만들 수 있을까요?
RISC-V 어셈블리어에는 뺄셈 인스트럭션이 있습니다.

```text
sub rd, rs1, rs2
```

이 인스트럭션은 `rs1`에서 `rs2`를 뺀 것을 `rd`에 넣습니다.
여기에는 이미디에이트 값을 쓰지 않기 때문에, 두 개의 레지스터를 사용해야 합니다.

다음을 어셈블리어로 만들어보세요.

```c
int foo = 42;
int main(void) {
  return 99 - foo;
}
```

`add.S` 파일을 `sub.S` 파일로 복사해서 약간만 수정해 해결해보시기 바랍니다.



# 할당 구현하기

앞서 메모리의 값을 레지스터에 가져오는 `lw` 인스트럭션을 사용했습니다.

```asm
  lw a0, foo
```

이번에는 반대로 레지스터의 값을 메모리에 써보겠습니다.
이를 통해 다음과 같은 할당 연산자를 구현해볼 것입니다.

```c
int foo = 42;

int main(void) {
  foo = 99;
  return foo;
}
```

RISC-V 어셈블리어에는 이를 위한 `sw` 인스트럭션이 있으므로, 바로 만들어볼 수 있습니다

## 어셈블리어로 옮기기

앞서 `add.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`assign.S` 파일을 만들어서 엔트리 포인트를 작성합니다.

```asm
_start:
  /* foo = 99 */
  la a0, foo
  li a1, 99
  sw a1, 0(a0)
```

`a0` 레지스터는 `foo`의 주소를, `a1` 레지스터에는 `99`를 넣습니다.
그리고 `sw` 인스트럭션은 'Store Word'로서, `a1` 레지스터의 값을 워드로서 메모리에 넣습니다.
그 주소는 `a0` 레지스터의 값을 사용하며, `0`은 그로부터 얼마나 떨어진 곳인지를 지정하는 값입니다.

이어서, `foo`의 값을 종료 코드로 리턴합니다.

```asm
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

실행하면 `99`를 종료 코드로 리턴할 것입니다.

메모리로부터 값을 가져오는 방법과, 메모리에 값을 넣는 방법을 알아보았습니다.
여기까지의 내용을 응용해서, 다음을 어셈블리어로 만들어보시기 바랍니다.

```c
int foo = 42;

int main(void) {
  foo++;
  return foo;
}
```

`assign.S` 파일을 `inc.S` 파일로 복사해서 약간만 수정해 해결해보시기 바랍니다.



# 조건문 구현하기

이번에는 다음과 같은 조건문을 만들어볼 것입니다.

```c
if (foo == 42) {
  foo++;
}
```

프로그램이 메모리에 올라오면, 프로그램 카운터가 다음 인스트럭션의 주소로 바뀌면서 각 인스트럭션이 순차적으로 실행된다고 설명했습니다.

하지만 조건문을 구현하기 위해서는 그 실행 흐름을 바꿀 필요가 있습니다.
즉 나중의 코드로 건너뛰기 위해 `pc` 레지스터의 값을 바꾸는 것입니다.

RISC-V 어셈블리어에는 그런 명령어가 있습니다.
이를 통해 나중의 코드로 건너뛰면 조건문을 만들 수 있게 되고, 이전의 코드로 돌아오면 반복문이 됩니다.
여기서는 먼저 조건문을 만들어보겠습니다.

## `if` 조건문 구현하기: 컨디셔널 브랜치

앞서 `assign.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`if.S` 파일을 만들어서, 먼저 두 레지스터를 초기화하겠습니다.

```asm
_start:
  /* initialize */
  lw a0, foo
  li a1, 42
```

이들은 조건문의 비교 조건에서 사용할 것입니다.

이어서, `if` 조건문을 만듭니다.

```asm
  /* if (foo == 42) */
  bne a0, a1, if_end
  /* foo++ */
  addiw a0, a0, 1
  la a1, foo
  sw a0, 0(a1)
if_end:
```

`bne` 인스트럭션은 'Branch Not Equal'로서, 두 레지스터 `a0`, `a1`이 같지 않으면 `if_end` 레이블로 건너뜁니다.
즉 그 다음 코드는 두 레지스터의 값이 같은 경우에 실행됩니다.
이처럼 인스트럭션의 동작은 조건문의 조건과 반대라는 점을 참고하세요.

이것은 상황에 따라 실행 흐름을 나누기 때문에, RISC-V 아키텍처에서 컨디셔널 브랜치<L>conditional branch</L>라고 부릅니다.
이와 달리 무조건적으로 건너뛰는 인스트럭션은 언컨디셔널 점프<L>unconditional jump</L>라고 부릅니다.
이 또한 잠시 후에 만날 것입니다.

마지막으로, `foo` 값을 종료 코드로 리턴합니다.

```asm
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

이것을 실행하면, 조건문 부분이 실행되어 종료 코드 `43`을 리턴할 것입니다. (한번 해보세요.)
만약 `foo`의 값을 다른 것으로 바꿔서 실행하보면, 조건문은 실행되지 않으므로 `42`를 리턴하게 됩니다. (이것도 해보세요.)

## 복잡한 조건 구현하기: 쇼트 서킷 연산자

앞서 배웠던 것을 응용해서, 다음과 같은 복잡한 조건에 도전해볼 수도 있습니다.

```c
if (42 <= foo && foo <= 44) {
  foo++;
}
```

여기서 두 조건이 참일 때만 참 값을 내놓는 `&&` 연산자는 양쪽을 항상 확인하지는 않습니다.
즉 왼쪽이 거짓이면 오른쪽을 확인하지 않고 바로 거짓 값을 내놓습니다.
이런 동작을 쇼트 서킷<L>short circuit</L>이라고 부릅니다.

이것은 앞서 만든 코드를 조금 수정해서 금방 만들 수 있습니다.
`if.S` 파일을 `if_and.S` 파일로 복사해서 구현해보세요.
만드는 방법은 어렵지 않으므로 직접 해보는 것으로 남기겠습니다.
다만 조건이 부등식인데, 다음과 같은 인스트럭션을 이용해보세요.

```asm
blt rs1, rs2, label
```

`blt` 인스트럭션은 'Branch Less Than'으로, `rs1` 레지스터 값이 `rs2` 레지스터 값보다 작을 때 `label`로 건너뜁니다.
또는 이와 반대인 `bgt` 인스트럭션을 이용할 수도 있습니다.

```asm
bgt rs1, rs2, label
```

이것은 'Branch Greater Than'으로, `rs1` 레지스터 값이 더 클 때 건너뜁니다.

## `else` 조건문 구현하기: 언컨디셔널 점프

앞서 언급했듯이, 무조건적으로 건너뛸 수도 있습니다.
대표적으로는 `j` 인스트럭션이 있습니다.

```asm
  j foo
  /* ... */

foo:
```

이것은 프로그램 카운터의 값을 `foo` 레이블의 주소로 바꿔서 실행 흐름을 건너뛰게 만듭니다.

이를 통해 `else` 조건문을 만들 수 있습니다.
`if.S` 파일을 `if_else.S` 파일로 복사해서 다음 조건문을 구현해보세요.

```c
if (foo == 42) {
  foo++;
} else {
  foo += 2;
}
```

만드는 방법은 어렵지 않으므로 직접 해보는 것으로 남기겠습니다.



# 배열 구현하기

반복문을 구현해보기 전에, 잠깐 배열을 짚고 넘어가봅시다.

```c
int arr[] = { 42, 99, 1 };
```

배열이란 연속된 메모리 할당<L>contiguous memory allocation</L>입니다.
어셈블리어에서 메모리 공간을 할당하는 것은 간단하기 때문에 바로 만들어볼 수 있습니다.

## 어셈블리어로 옮기기

임의의 크기로 메모리를 할당하는 것은 `.skip` 지시자를 이용합니다.

```asm
  .data
arr:
  .skip 12
```

이것은 12 바이트 공간을 할당합니다.
`int` 타입이 4 바이트라고 가정했기 때문에, 세 원소를 위한 크기가 됩니다.
여기에는 값이 `0`으로 채워집니다.

만약 구체적인 값을 담고 싶다면, 이렇게 쓸 수도 있습니다.
다음을 `array.S` 파일로 만들어봅시다.

```asm
  .data
arr:
  .word 42
  .word 99
  .word 1
```

아래 두 `.word` 지시자에는 값만 있을 뿐 레이블이 없다는 점을 참고하세요.
마치 C 언어에서 배열 변수가 첫 번째 원소의 주소를 가리키듯, `arr` 레이블도 첫 번째 원소를 가리킵니다.

과연 컴파일러가 실제로 이렇게 컴파일할까요?
`array_c.c` 파일에 다음과 같이 C 언어를 작성해봅시다.

```c
int arr[] = { 42, 99, 1 };

int main(void) {
  return 0;
}
```

이것을 컴파일합니다.

```shellsession
$ gcc -nostdlib -S -O0 array_c.c
```

`array_c.s` 파일에서 컴파일된 어셈블리어를 볼 수 있습니다.
결과가 어떤지 `data` 섹션을 확인해보세요.

## 배열의 원소 더하기

한번 배열의 원소를 더하는 문제를 생각해봅시다.
여기서는 간단히 다음과 같이 해결해보겠습니다.

```c
int arr[3] = { 42, 99, 1 };
int sum = 0;

int main(void) {
  sum += arr[0];
  sum += arr[1];
  sum += arr[2];
  return sum;
}
```

방금 작성한 `array.S` 파일에 다음 코드를 이어서 작성합니다.

```asm
_start:
  /* initialize */
  li a0, 0 /* sum */
  la a1, arr
```

가상의 C 코드는 `sum` 변수를 사용했지만, 여기서는 `a0` 레지스터에 바로 합을 담을 것입니다.

이어서, 첫 번째 원소를 더해봅시다.

```asm
  /* a0 += arr[0] */
  lw a2, 0(a1)
  addw a0, a0, a2
```

여기서 `0(a1)` 표현은 `a1` 레지스터의 값에서 `0` 만큼 떨어진 곳을 주소로 이용한다는 뜻입니다.
이것은 `arr` 레이블의 위치와 같습니다.

두 번째 원소는 이렇게 더할 수 있습니다.

```asm
  /* a0 += arr[1] */
  lw a2, 4(a1)
  addw a0, a0, a2
```

`4(a1)` 표현은 `arr` 레이블에서 `4` 바이트 떨어진 곳을 가리키므로, 두 번째 원소가 됩니다.
마찬가지로 세 번째 원소를 직접 더해보시기 바랍니다.

마지막에는 합을 종료 코드로 리턴합니다.

```asm
  /* exit(a0) */
  li a7, 93
  ecall
```

실행하면 종료 코드는 합인 `142`가 됩니다. (확인해보세요.)



# 반복문 구현하기

배열의 원소를 일일이 더하는 대신, 반복문을 이용해봅시다.

```c
int arr[3] = { 42, 99, 1 };
int i = 0;
int sum = 0;

int main(void) {
  for (; i < 3; i++) {
    sum += arr[i];
  }

  return sum;
}
```

위 코드처럼, 반복문을 통해 합을 구하는 것이 목표입니다.

## 어셈블리어로 옮기기

앞서 언급했듯이, 반복문은 코드를 이전으로 건너뛰어서 만들 수 있습니다.
`for.S` 파일을 만들어서, 배열을 만드는 것으로 시작해봅시다.

```asm
  .data
arr:
  .word 42
  .word 99
  .word 1
```

엔트리 포인트는 다음과 같습니다.

```asm
_start:
  /* initialize */
  li a0, 0 /* sum */
  li a1, 0 /* i */
  li a2, 3
```

예시의 `sum`과 `i` 변수 대신, 여기서는 `a0`, `a1` 레지스터를 이용하겠습니다.
`a2` 레지스터의 값 `3`은 반복문의 조건에 쓸 것입니다.

`for` 반복문의 조건을 구현합니다.

```asm
for_start:
  /* (for) i < 3; */
  bge a1, a2, for_end
```

조건을 만족하지 않는 경우 `for_end` 레이블로 건너뜁니다.
이 레이블은 나중에 작성할 것입니다.

배열의 원소를 가져오기 위해, `i` 값을 가진 `a1` 레지스터로부터 원소의 주소를 계산합니다.

```asm
  /* a3 = i * 4 */
  mv a3, a1
  slli a3, a3, 2
```

위 코드는 `a1` 레지스터 값의 네 배를 가져옵니다.
각 원소가 4 바이트씩 떨어져 있기 때문입니다.

`mv` 인스트럭션은 단순히 `a3` 레지스터에 `a1` 레지스터 값을 넣습니다.
`slli` 인스트럭션은 'Shift Left Logical Immediate'로서, 왼쪽으로 비트를 시프트하는 연산입니다.
예를 들어, 레지스터에 `11`이라는 표현이 들어있을 때 두 비트만큼 시프트 하면 결과는 `1100`가 됩니다.
그리고 이것은 정수 값을 네 배하는 것과 같습니다.

이어서, `a4` 레지스터에 원소의 주소를 넣습니다.

```asm
  /* a4 = arr + a3 */
  la a4, arr
  add a4, a4, a3
```

그 주소로 접근해 원소의 값을 `a5` 레지스터에 넣습니다.

```asm
  /* a5 = arr[a4] */
  lw a5, 0(a4)
```

그 원소의 값을 `sum` 값으로서 `a0` 레지스터에 더합니다.

```asm
  /* sum += a5 */
  add a0, a0, a5
```

반복문의 마지막으로서, `i`를 하나 올리고 시작으로 돌아가 반복합니다.

```asm
  addi a1, a1, 1
  j for_start
for_end:
```

합이 들어있는 `a0` 레지스터의 값을 종료 코드를 리턴합니다.

```asm
  /* exit(a0) */
  li a7, 93
  ecall
```

실행하면 종료 코드는 `142`가 됩니다. (한번 해보세요.)

이렇게 만든 반복문 코드와, 반복문을 쓰지 않았던 `array.S` 파일을 비교해보세요.
어느쪽이 인스트럭션을 덜 사용할까요?
작은 루프의 경우, 반복문을 쓰지 않는 쪽이 오히려 더 짧을 수도 있습니다.
따라서 컴파일러는 이런 경우에 반복문을 풀어서 단순히 일일이 나열하기도 합니다.



# 함수 구현하기

함수 또한 실행 흐름을 건너뛰는 것으로 구현할 수 있습니다.
즉 조건문과 반복문을 만들 때와 마찬가지입니다.
하지만 실제로는 그것보다 조금 더 부가적인 작업이 필요합니다.
왜냐면 함수 호출 시 인자를 처리해야 하고, 호출이 끝났을 때 호출자의 입장에서는 아무 일도 일어나지 않은 것처럼 레지스터의 값이 보존되어야 하기 때문입니다.

여기서 함수는 두 단계를 거쳐 만들어볼 것입니다.
첫 번째는 다른 함수의 호출이 없는 함수, 즉 리프<L>leaf</L> 함수이고, 그 다음은 자기 자신을 호출하는 재귀<L>recursive</L> 함수입니다.
이를 통해 호출이 끝날 때 레지스터의 값을 보존하는 방법을 알게 될 것입니다.

## 리프 함수 만들기

다음과 같은 간단한 함수를 만들어보겠습니다.

```c
int foo = 42;

void set_foo(int n) {
  foo = n;
}

int main(void) {
  set_foo(99);
  return foo;
}
```

인자 값으로 `foo` 변수의 값을 바꾸는 `set_foo()` 함수가 목표입니다.
이를 통해 함수의 인자를 처리하는 방법을 볼 것입니다.

앞서 `if.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`leaf.S` 파일을 만들어서 엔트리 포인트를 작성합니다.

```asm
_start:
  /* set_foo(99) */
  li a0, 99
  jal set_foo
```

`99`를 인자로 함수를 호출하는 부분입니다.
함수의 첫 번째 인자는 `a0`로 전달합니다.
`jal` 인스트럭션은 `set_foo` 레이블로 점프합니다.
이것과 기존 `j` 인스트럭션의 차이는 곧 설명할 것입니다.

이어서, 종료 코드를 리턴합니다.

```asm
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

그 다음에 `set_foo` 레이블을 시작으로 함수의 내용을 작성합니다.

```asm
set_foo:
  /* foo = a1 */
  la a1, foo
  sw a0, 0(a1)

  ret
```

첫 번째 인자는 `a0` 레지스터로 넘어옵니다.
이것을 `foo` 변수의 값에 넣습니다.
마지막에 `ret` 인스트럭션은 호출한 쪽으로 점프시켜서, 마치 함수를 호출한 것처럼 만듭니다.

위 코드를 실행하면 종료 코드는 `99`가 됩니다. (한번 해보세요.)

## 리턴 어드레스: `ra` 레지스터

방금의 경우처럼 `ret`과 `jal` 인스트럭션은 짝으로 사용됩니다.
그런데 `ret`은 돌아갈 주소를 어떻게 알았을까요?

`set_foo()` 함수를 호출했던 `jal` 인스트럭션은 바로 다음에 위치한 인스트럭션의 주소를 어딘가에 기억해둔 것입니다.
다시 말해, 그 주소는 `jal` 인스트럭션을 실행할 당시의 `pc+4` 값입니다.
이는 리턴 어드레스<L>return address</L>라고 부르고, RISC-V 아키텍처에서는 이것을 기억하기 위해 `ra` 레지스터를 사용합니다.

그리고 `ret` 인스트럭션은 `ra` 레지스터의 값으로 점프합니다.
직접 작성하지는 않았지만, 보이지 않게 리턴 어드레스가 사용된 것입니다.

## 재귀: 스택 포인터 `sp`

함수 안에서 또 함수를 호출해야 한다면 어떨까요?
예를 들어, 다음과 같이 코드를 작성했다고 해봅시다.

```asm
_start:
  jal wrapper
  /* ... */

wrapper:
  li a0, 99
  jal set_foo

  ret
```

이것은 `set_foo()` 함수의 호출을 다른 함수로 옮긴 것 뿐입니다.
즉 엔트리 포인트에서 `wrapper()` 함수를 호출하고, 여기서 기존의 `set_foo()` 함수를 호출합니다.

그렇다면 이 코드가 잘 동작할까요?
결론부터 말하면 그렇지 않습니다.
왜냐면 `ra` 레지스터의 값이 두 번 바뀌고 나서, 기존에 엔프리 포인트로 돌아갈 리턴 어드레스를 잃어버리기 때문입니다.

엔트리 포인트에서 호출했던 `wrapper()` 함수는 호출이 끝나면 엔트리 포인트 쪽으로 돌아오길 기대합니다.
하지만 `set_foo()` 함수의 호출이 끝났을 때 `ra` 레지스터의 값을 주목해보면, `wrapper()` 함수에 있는 `ret` 인스트럭션의 주소로 바뀌게 됩니다.
따라서 `wrapper()` 함수의 `ret` 명령을 실행하면 자기 자신으로 계속 되돌아오게 됩니다.

이 문제를 해결하는 방법은 리턴 어드레스를 메모리에 잠깐 보관해두는 것입니다.
그런데 만약 함수를 여러번 호출했다면, 가장 마지막 리턴 어드레스가 필요할 것입니다.
그러므로 가장 마지막에 넣은 데이터를 가장 먼저 꺼낼 수 있는 데이터 구조인 스택<L>stack</L>을 사용해서 해결합니다.

이 스택은 메모리 상에서 어딘가에 위치하게 되는데, 이를 스택 메모리라고 부릅니다.
그리고 가장 마지막에 넣은 데이터의 위치를 스택 포인터<L>stack pointer</L>라고 부릅니다.

<Figure src={fig8} alt="hex value of a specific addiw instruction">
  <FigureCaption slot="caption">그림 8. 스택 메모리 다이어그램. `sp` 레지스터는 스택 포인터로서 마지막에 넣은 데이터의 주소를 가리킵니다. RISC-V 아키텍처에서 스택은 낮은 메모리 주소를 향해 커지기 때문에, `sp` 레지스터는 스택 메모리 공간의 가장 낮은 주소를 가집니다.</FigureCaption>
</Figure>

RISC-V 아키텍처는 이 스택 포인터를 기억하기 위한 `sp` 레지스터를 갖고 있습니다.
이를 이용해 스택에 데이터를 넣거나 뺍니다.

## 재귀 함수 만들기

앞서 언급한 내용이 재귀 함수를 만들 때 어떻게 활용되는지 바로 살펴보겠습니다.
여기서 만들 함수는 다음과 같습니다.

```c
int sum(int n) {
  if (n <= 0) {
    return 0;
  }
	
  return n + sum(n-1);
}

int main(void) {
  return sum(10);
}
```

`sum()` 함수는 인자 $n$을 받으면 $0$부터 $n$까지의 합을 리턴합니다.

다음과 같이 `recur.S` 파일을 만들고 엔트리 포인트를 작성해봅시다.

```asm
_start:
  /* sum(10) */
  li    a0, 10
  jal   sum

  /* exit(sum(10)) */
  li    a7, 93
  ecall
```

이 부분은 앞서 했던 것과 같이, `sum()` 함수를 호출하고 그 결과를 종료 코드로 리턴합니다.

이어서, `sum()` 함수를 작성합니다.

```asm
sum:
  /* allocate stack */
  addi sp, sp, -16
```

먼저, 스택 메모리를 16 바이트 증가시킵니다.
이것은 스택 포인터를 16 바이트 감소시켜서 구현합니다.
RISC-V 아키텍처에서 스택은 낮은 주소를 향해 커지기 때문입니다.

여기에 리턴 어드레스를 넣습니다.

```asm
  /* push ra to stack */
  sd ra, 8(sp)
```

RISC-V 아키텍처에서 레지스터의 크기는 32 비트인 경우도 있고 64 비트인 경우도 있습니다.
여기서는 64 비트인 것을 사용합니다.
(다른 여러 아키텍처 또한 64 비트 레지스터를 사용합니다.)
이는 컴파일러를 `-march=rv64g` 옵션으로 실행했던 이유이기도 합니다.
아키텍처를 지정하는 이 옵션에서 `64`가 바로 레지스터의 64 비트 크기를 가리킵니다.

64 비트는 두 개의 워드, 즉 더블 워드<L>double word</L>입니다.
`sd` 인스트럭션은 더블 워드 크기의 값을 메모리에 넣습니다.
위 코드는 스택에 할당했던 16 바이트 중 높은 주소 쪽의 8 바이트에 값을 넣습니다.

<Figure src={fig9} alt="return address pushed to stack">
  <FigureCaption slot="caption">그림 9. 스택에 들어간 리턴 어드레스.</FigureCaption>
</Figure>

그 다음, 조건문을 처리합니다.
인자가 `0` 이하인 경우, 곧바로 `0`을 리턴하도록 만듭니다.

```asm
  /* if (n <= 0) */
  bgt a0, x0, if_end
  /* return 0 */
  li a0, 0
  ret
if_end:
```

함수의 마지막에는 다시 자기 자신을 호출하는 부분이 있습니다.
이 함수는 `a0` 레지스터를 이용하기 때문에, 기존의 `a0` 레지스터를 기억해둬야 합니다.
따라서 스택에 넣습니다.

```asm
  /* push a0 to stack */
  sw    a0, 4(sp)
```

여기서 스택에 할당한 16 바이트를 모두 사용하지 않지만, 스택 포인터는 항상 16 바이트로 얼라인해야 한다는 점을 참고하세요.
RISC-V 아키텍처의 요구 사항이기 때문입니다.

이제 재귀를 안전하게 수행합니다.
인자는 기존에서 하나 작은 값을 넘깁니다.

```asm
  /* sum(n-1) */
  addi  a0, a0, -1
  jal   sum
```

함수가 끝났다면 스택에 넣어둔 값을 다시 꺼내고, 빌렸던 메모리를 반납합니다.

```asm
  /* pop a0 from stack */
  lw    a1, 4(sp)
  add   a0, a0, a1
  /* pop ra from stack */
  ld    ra, 8(sp)
  /* deallocate stack */
  addi  sp, sp, 16

  ret
```

함수의 리턴 값은 `a0` 레지스터로 전달하므로, 자연스럽게 합이 리턴됩니다.
그리고 `ret` 인스트럭션은 스택에서 꺼낸 `ra` 레지스터의 값으로 돌아가게 됩니다.

실행하면 종료 코드는 합인 `55`가 됩니다. (확인해보세요.)



# 세부 사항

여기까지 목표한대로 변수, 조건문, 반복문, 그리고 함수를 어셈블리어로 구현했습니다.
하지만 구현에 집중했기 때문에 설명을 건너 뛰었던 부분이 남아있기도 합니다.
여기서는 그러한 부분을 정리하며 마무리해보겠습니다.

## 콜링 컨벤션

함수 호출 시 `a0` 레지스터를 통해 인자와 리턴 값을 주고 받았습니다.
그런데 다른 레지스터를 이용하면 안 될까요?
사실 이렇게 레지스터를 쓰는 것은 콜링 컨벤션<L>calling convention</L>이라는 이름으로 정해진 규칙입니다.

RISC-V 아키텍처는 32 개의 범용<L>general purpose</L> 레지스터를 갖고 있고, `x0` 부터 `x31` 까지의 이름으로 불립니다.
다만 `x0` 레지스터는 값이 항상 `0`으로 고정되어 있기 때문에, 실제로 자유롭게 쓸 수 있는 레지스터는 31 개입니다.

한편, 여태 `ra` 레지스터라고 불렀던 것은 사실 `x1` 레지스터입니다.
그런데 범용 레지스터라고 불리는 만큼, 다른 레지스터로 리턴 어드레스를 기억해도 상관은 없습니다.
하지만 C 컴파일러는 콜링 컨벤션을 따라 레지스터를 이용하기 때문에, 이것과 연동하려는 코드라면 똑같이 따라야합니다.

이 콜링 컨벤션은 애플리케이션 바이너리 인터페이스<L>application binary interface</L>, 또는 ABI 라고 불리는 것에 포함됩니다.
그리고 `ra` 레지스터와 같은 이름은 ABI 이름<L>ABI name</L>이라고 부릅니다.

<Figure src={fig10} alt="registers">
  <FigureCaption slot="caption">그림 10. RISC-V 아키텍처의 레지스터 일부.</FigureCaption>
</Figure>

콜링 컨벤션에 따르면 `a0` 부터 `a7` 까지의 레지스터는 호출 인자로 사용합니다.
그리고 콜러 세이브<L>caller-save</L> 레지스터로서, 호출한 쪽에서 값을 보존해야 합니다.
이런 이유로 앞서 `sum()` 함수가 재귀 호출을 앞두고 `a0` 레지스터의 값을 스택에 넣었던 것입니다.

한편, `sp` 레지스터는 콜리 세이브<L>callee-save</L> 레지스터로, 호출된 쪽에서 보존해야 합니다.
즉 호출한 쪽에서는 함수가 끝났을 때 값이 유지될거라고 생각해도 되는 것입니다.
앞서 `sum()` 함수가 끝날 때 스택 포인터를 원래대로 되돌려놓았던 이유이기도 합니다.

## 시스템 콜: `ecall`

앞서 시스템 콜을 `ecall` 인스트럭션으로 호출했습니다.
그런데 시스템 콜 코드는 어디에도 직접 쓴 적이 없습니다.
그렇다면 시스템 콜은 어떻게 호출된 것일까요?

시스템 콜의 구현은 운영 체제의 커널<L>kernel</L>이라고 부르는 부분에 위치합니다.
하지만 이 부분은 직접 접근할 수는 없도록 설계되어 있습니다.
그 이유는 운영 체제 입장에서 모든 코드를 믿을 수는 없기 때문입니다.

코드는 두 가지로 나눠볼 수 있습니다.
하나는 믿을 수 있는 것이고, 또 하나는 악의적일 가능성이 있어서 믿을 수 없는 것입니다.
커널에 위치한 코드, 즉 커널 코드<L>kernel code</L>는 첫 번째에 속하고, 앞서 만든 코드는 유저 코드<L>user code</L>라고 부르며 두 번째에 속합니다.

정리하면 시스템 콜은 커널 코드이며, 유저 코드가 임의로 접근할 수 없도록 보호를 받습니다.
그리고 이러한 보호는 인스트럭션 차원에서도 제공됩니다.
즉 어떤 것은 자유롭게 실행할 수 있는 반면, 다른 것은 특별한 권한이 있을 때만 실행할 수 있습니다.

흔히 어셈블리어에서는 권한을 유저 모드<L>user mode</L>와 이보다 높은 커널 모드<L>kernel mode</L>로 나눠서, 어떤 인스트럭션은 커널 모드가 필요하도록 설계합니다.
RISC-V 아키텍처는 각각을 언프리빌리지드 모드<L>unprivileged mode</L>와 프리빌리지드 모드<L>privileged mode</L>라고 부릅니다.

앞서 작성한 `li` 인스트럭션과 같은 것은 프리빌리지드 모드가 필요 없기 때문에 자유롭게 쓸 수 있었던 것입니다.
이러한 인스트럭션은 언프리빌리지드 인스트럭션이라고 부릅니다.
반면 프리빌리지드 모드가 필요하다면 말 그대로 프리빌리지드 인스트럭션이라고 부릅니다.
이것은 커널 관련 작업과 같은 특별한 상황에서 사용하므로 여기서는 다루지 않겠습니다.

요점은 시스템 콜의 코드는 프리빌리지드 모드가 필요하다는 것입니다.
그러면 어떻게 유저 코드가 시스템 콜을 수행할 수 있는 것일까요?
시스템 콜을 수행하기 전에 어느 시점에서는 반드시 권한을 바꿀 필요가 생기는데 말입니다.

이것은 `ecall` 인스트럭션이 맡은 역할입니다.
즉 권한을 바꾼 다음, 시스템 콜을 처리하기 위한 코드로 점프합니다.
그리고 시스템 콜이 끝나면 함수 호출이 끝난 것처럼 되돌아옵니다.
마치 앞서 만났던 함수 구현과 비슷한 방식입니다.

<Figure src={fig11} alt="registers">
  <FigureCaption slot="caption">그림 11. 프로그램의 메모리 레이아웃 예시. 힙은 동적 할당을 위한 메모리 공간을 맡습니다.</FigureCaption>
</Figure>

위 내용을 통해, 왜 C 언어에서 `malloc()` 함수를 통한 메모리의 동적 할당이 지역 변수를 사용하는 것보다 느린지 알게 됩니다.
`malloc()` 함수는 내부적으로 또 다른 시스템 콜을 사용하고, 이것은 힙<L>heap</L>이라고 불리는 메모리 공간에서 빈 공간을 찾아 할당합니다.
이 작업은 스택 메모리를 사용하는 것에 비해 더 많은 인스트럭션을 수행하게 됩니다.

## 코드 최적화: 컴파일러에 맡기기

앞서 컴파일러에게 최적화를 하지 않도록 `-O0` 옵션으로 컴파일했습니다.

```shellsession
$ gcc -nostdlib -S -O0 int_c.c
```

읽기 쉬운 어셈블리어 결과를 얻기 위해서 여기서는 이렇게 했지만, 보통은 최적화를 켜놓는 것이 좋습니다.

그렇다면 컴파일러는 코드를 구체적으로 어떻게 최적화할까요?
여기에는 다양한 방법이 있겠지만, 다음과 같은 간단한 경우를 한번 봅시다.

```c
int main(void) {
  int sum = 0;
  for (int i = 1; i <= 10; i++) {
    sum += i;
  }
  return sum;
}
```

$1$부터 $10$까지의 합을 구하는 코드입니다.

이것을 `opt.c` 파일로 만들겠습니다.
그리고 `-O3` 옵션으로 가장 높은 수준의 코드 최적화를 맡겨봅시다.

```shellsession
$ gcc -nostdlib -S -O3 opt.c
```

결과로 나온 `opt.s` 파일을 봅시다.
그러면 반복문은 다음과 같이 컴파일됩니다.

```asm
  li  a0,55
```

즉 컴파일러가 미리 반복문의 결과를 계산한 것입니다.
앞서 반복문을 구현할 때 많은 인스트럭션이 필요했다는 사실에 비춰보면, 이렇게 한 줄로 줄인 것은 상당한 최적화입니다.

이 결과는 프로그래머 자신이 직접 최적화하는 것은 피해야 한다는 교훈을 줍니다.
컴파일러는 프로그래머보다 더 빠르고 안전하게 최적화를 해내기 때문입니다.
또 다른 예시로 다음 코드를 봅시다.

```c
  foo * 4;
```

어떤 프로그래머는 이 C 코드를 보고, 비트 시프트 연산이 훨씬 더 빠르다고 생각해서 다음과 같이 '최적화'를 할 수도 있습니다.

```c
  foo << 2;
```

하지만 이 표현은 곱하기라는 원래의 의미를 잃어버립니다.
게다가 컴파일러는 이러한 최적화를 알아서 해줍니다.
궁금하다면 다음 함수를 컴파일해봅시다.

```c
int quad(int n) {
  return n * 4;
}
```

컴파일러는 다음 결과를 내놓습니다.

```asm
  slliw	a0,a0,2
  ret
```

`slliw` 인스트럭션은 왼쪽 시프트 연산을 워드 크기에 대해 수행합니다.
즉 곱셈이 비트 시프트로 바뀌며 최적화된 것입니다.
따라서 프로그래머는 곱하기의 의미를 그대로 살려서 쓰더라도 비트 시프트만큼 빠른 성능을 갖게 됩니다.






# 마치며

본문의 소스 코드는 [깃허브][gh]<L>GitHub</L>에서 확인할 수 있습니다.

[gh]: https://github.com/wcho21/langwalk/tree/main/riscv

## 레퍼런스

- [*The RISC-V Reader*][riscv-reader]: RISC-V 아키텍처의 간략한 소개.
- [*An Introduction to Assembly Programming with RISC-V*][intro-asm-riscv]: RISC-V 어셈블리어 프로그래밍 소개.
- [*The RISC-V Instruction Set Manual*][riscv-isa-man]: RISC-V 인스트럭션 매뉴얼.
- [*RISC-V Assembly Programmer's Manual*][riscv-prog-man]: 
- [*RISC-V ABIs Specification*][riscv-abi]
- [*Using `as`*][gnu-as]: GNU 어셈블러 `as` 매뉴얼.
- [*Options for Linking*][gcc-opt-link], [*RISC-V Options*][gcc-opt-riscv]: GNU 컴파일러 `gcc` 매뉴얼.
- [`exit()`][man-exit], [`write()`][man-write]: 시스템 콜 매뉴얼.
- [`unistd.h`][unistd-h]: 리눅스 커널 시스템 콜 헤더 파일.

더 자세한 내용이 궁금하다면 다음 자료를 참고해볼 수 있습니다.

- *Computer Organization and Design (RISC-V Edition)* (David Patterson, John Hennessy, 2020), 또는 *컴퓨터 구조 및 설계 RISC-V* (한티미디어, 2022): RISC-V 인스트럭션의 하드웨어 구현을 자세히 소개.
- *The Art of ARM Assembly, Volume 1* (Randall Hyde, 2025): ARM 아키텍처 어셈블리어 프로그래밍 소개. 어셈블리어에서 나타나는 공통적인 컨셉을 살펴볼 수 있습니다.

[riscv-reader]: http://riscvbook.com/korean/risc-v-reader-korean-v1p0.pdf
[intro-asm-riscv]: https://riscv-programming.org/book/riscv-book.html
[riscv-isa-man]: https://github.com/riscv/riscv-isa-manual/releases/tag/20250508
[riscv-prog-man]: https://github.com/riscv-non-isa/riscv-asm-manual/releases/tag/v0.0.1
[riscv-abi]: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases/tag/v1.0
[gnu-as]: https://sourceware.org/binutils/docs/as/
[gcc-opt-link]: https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Link-Options.html
[gcc-opt-riscv]: https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/RISC-V-Options.html
[man-exit]: https://man7.org/linux/man-pages/man2/_exit.2.html
[man-write]: https://man7.org/linux/man-pages/man2/write.2.html
[unistd-h]: https://github.com/torvalds/linux/blob/v6.13/include/uapi/asm-generic/unistd.h




