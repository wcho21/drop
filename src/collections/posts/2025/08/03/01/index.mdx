---
title: "어셈블리 프로그래밍 시작하기"
date: 2025-08-03T01:00:00+09:00
summary: "?"
thumbnail: "/src/assets/thumbnails/2025/08/03/01/thumbnail.webp"
series: "프로그래밍 언어 산책"
---

import L from "@/components/post/AltLang.astro";
import P from "@/components/post/pseudocode";
import Figure from "@/components/post/Figure.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";
import FigureDisplay from "@/components/post/FigureDisplay.astro";
import Quote from "@/components/post/Quote.astro";

import fig1 from "./figs/fig1.jpg";



프로그래밍은 보통 C 언어와 같은 고수준<L>high-level</L> 프로그래밍 언어를 사용하지만, 컴퓨터가 직접 이해할 수 있는 것은 그런 언어가 아닌 기계어<L>machine language</L>입니다.
그러므로 고수준 언어를 기계어로 바꿀 필요가 생기게 되고, 컴파일러가 그 역할을 맡습니다.

대부분의 프로그래밍은 기계어 수준까지 신경 쓸 필요는 없습니다.
하지만 신경 쓸 필요가 없다는 것이 곧 배울 필요가 없다는 말은 아닙니다.
기계어에 가까운 어셈블리어<L>assembly language</L>로 프로그램을 만들어보면 다음과 같은 것을 알 수 있게 됩니다.

- 컴퓨터가 프로그램을 메모리에 올리고 실행하는 과정
- 지역 변수는 빠르고 동적 할당은 느린 이유
- 최적화를 컴파일러에 맡기는 것이 나은 이유

여기서는 어셈블리어를 배우기 위해, 가상의 C 코드를 어셈블리어로 옮겨볼 것입니다.
즉 컴파일러 자체가 되어보는 것입니다.
구체적으로는 다음과 같은 내용을 다룹니다.

- 정수, 배열, 스트링 변수를 만드는 방법
- 조건문과 반복문을 만드는 방법
- 함수를 만드는 방법

어셈블리어에는 변수 타입, 조건문, 반복문, 함수와 같은 개념이 존재하지 않습니다.
따라서 이러한 고수준 언어의 기능을 어떻게 어셈블리어로 만들어낼 수 있는지 보게 될 것입니다.

<Figure src={fig1} alt="Processor">
  <FigureCaption slot="caption">그림 1. 인텔 사 프로세서. -- 사진: [Christian Wiediger][unsplash-cw]</FigureCaption>
</Figure>

[unsplash-cw]: https://unsplash.com/ko/사진/검은색-마더보드의-인텔-프로세서-CKpBhTXvLis

컴퓨터에서 기계어는 프로세서<L>processor</L>라고 부르는 장치가 해석하고 실행합니다.
따라서 어셈블리어란 이러한 프로세서를 직접적으로 조작하는 것과 같습니다.

한편, 프로세서는 다양한 종류가 존재하기 때문에 각각 다른 조작 방법을 가집니다.
달리 말하면, 어떤 조작 방법이 정해져 있을 때 그것을 하드웨어로 구현한 것이 프로세서라고 볼 수 있습니다.
이러한 조작 방법은 인스트럭션 세트 아키텍처<L>instruction set architecture</L>, 또는 간단히 아키텍처라고도 부릅니다.
여기에는 전체적인 조작 방법을 어떤 인스트럭션들로 구성할 것인지가 포함됩니다.

다양한 어셈블리어 종류 중에서, 여기서는 RISC-V 어셈블리어로 진행합니다.
명령어가 간단하고 명렁어 개수가 많지 않기 때문에 배우기가 비교적 쉽기 때문입니다.
물론 여기서의 목표는 RISC-V 어셈블리어 자체를 배우는 것이 아니라, 어셈블리어에서 나타나는 일반적인 컨셉을 알아보는 것입니다.

RISC-V 어셈블리어를 배우기 위해 필요한 것은 RISC-V 아키텍처를 가진 컴퓨터입니다.
즉 RISC-V 기계어로 컴파일할 수 있고, 그것을 실행할 수 있어야 합니다.
각각을 위해 RISC-V 아키텍처를 타겟으로 컴파일하는 크로스 컴파일러<L>cross compiler</L>와, RISC-V 가상 머신으로 진행합니다. 
이런 프로그램의 설치 방법은 여기서 다루지 않지만, 본문의 예시 코드가 있는 [깃허브][gh]<L>GitHub</L>의 설명을 참고해볼 수 있습니다.

크로스 컴파일러는 `gcc` 컴파일러를 이용합니다.
다음과 같이 버전을 확인할 수 있다면 설치된 것입니다.

```shellsession
$ riscv64-linux-gnu-gcc --version
riscv64-linux-gnu-gcc (Ubuntu 14.2.0-4ubuntu2) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

또한 가상 머신은 `qemu`를 이용합니다.
이것 또한 다음과 같이 설치를 확인할 수 있습니다.

```shellsession
$ qemu-riscv64 --version
qemu-riscv64 version 9.0.2 (Debian 1:9.0.2+ds-4ubuntu5.3)
Copyright (c) 2003-2024 Fabrice Bellard and the QEMU Project developers
```

여기서는 프로그래밍 경험이 조금이라도 있고, 조건문과 반복문, 함수가 무엇인지 알고 있다고 가정하고 설명합니다.
C 언어는 예시 코드에 사용하는 언어이므로 아는 것이 내용을 이해하는데 도움이 될 수는 있지만, 필수로 알아야 하는 것은 아닙니다.
그러면 시작해봅시다.



# 첫 프로그램 만들기

먼저 어셈블리어로 프로그램을 만드는 방법을 살펴봅니다.
한번 이것을 배우고나면, 나중에 더 복잡한 것을 만들 때 쉽게 이해할 수 있을 것입니다.

## 어셈블러로 실행 파일 만들기

가장 간단한 프로그램으로서, 실행하자마자 끝나는 빈 프로그램을 만들어봅시다.
다음 내용을 `empty.S` 파일로 만들겠습니다.

```asm
  .text
  .align 2

  .global _start
_start:
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

이것의 의미는 잠시 후 설명하기로 하고, 다음과 같이 크로스 컴파일러를 통해 기계어로 바꿔봅시다.

```shellsession
$ riscv64-linux-gnu-gcc -march=rv64g -mabi=lp64d -static -O0 -nostdlib empty.S
```

이처럼 어셈블리어를 기계어로 번역하는 프로그램을 어셈블러<L>assembler</L>라고 부릅니다.
여기서는 `a.out` 파일이 실행할 수 있는 프로그램으로 만들어지는데, 이것을 실행 파일<L>executable</L>이라고 부릅니다.

위와 같은 커맨드가 길다면, 다음과 같이 줄일 수도 있습니다.

```shellsession
$ alias gcc="riscv64-linux-gnu-gcc -march=rv64g -mabi=lp64d -static -O0"
$ gcc -nostdlib empty.S
```

앞으로는 이렇게 줄인 것을 사용하겠습니다.
여기서 사용된 `-march=rv64g`와 같은 옵션은 나중에 설명할 것입니다.

실행 파일을 다음과 같이 실행해봅시다.

```
$ ./a.out
```

마치 실행 파일을 직접 실행한 것처럼 보이지만, 보이지 않게 다음과 같은 커맨드로 바뀝니다.

```
$ qemu-riscv64 ./a.out
```

즉 RISC-V 아키텍처를 가진 가상 머신에서 실행하는 것입니다.

프로그램은 실행하자마자 종료됩니다.
다음과 같이 종료 코드<L>exit code</L>를 확인해봅시다.

```
$ echo $?
0
```

이 값은 다음 줄에서 온 것입니다.

```
  li a0, 0
```

정말일까요?
여기서 `0`을 `1`과 같이 다른 값으로 바꿔서 실행해보세요.

## 소스 코드 훑어보기

작성했던 코드의 의미를 간략하게 살펴보겠습니다.

다음과 같이 점으로 시작하는 것들은 어셈블러에 대한 명령입니다.

[gnu-as-directive]: https://sourceware.org/binutils/docs/as/Pseudo-Ops.html

```asm
  .text
  .align 2
```

이것은 [매뉴얼][gnu-as-directive]에서 볼 수 있듯이, 어셈블러 지시자<L>directive</L>라고 부릅니다.
여기서 `.text`는 다음에 올 것들이 프로세서에 대한 명령, 즉 인스트럭션이라고 어셈블러에게 알려주는데, 더 자세한 의미는 나중에 볼 것입니다.

모든 프로그램에는 엔트리 포인트<L>entry point</L>라고 부르는 시작점이 존재하고, 그 이름은 기본적으로 `_start`로 정해져있습니다.
다음 부분은 엔트리 포인트라고 나타내는 것입니다.

```asm
  .global _start
_start:
```

따라서 이후는 처음으로 실행할 인스트럭션입니다.

```asm
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

첫 줄은 코멘트에 해당합니다.
어셈블리어는 의미를 바로 파악하기가 쉽지 않기 때문에, 코드의 역할을 나타내기 위해 코멘트를 자주 활용할 것입니다.

`li` 인스트럭션은 레지스터에 값을 넣습니다.
여기서 레지스터<L>register</L>란 메모리의 일종으로, 나중에 자세히 살펴볼 것입니다.
즉 두 번째 줄은 `a0` 레지스터에 `0`을 넣는 것입니다.

`ecall` 인스트럭션은 시스템 콜<L>system call</L>을 호출합니다.
시스템 콜은 운영 체제가 제공하는 기본적인 함수입니다.
이때, `a7` 레지스터에는 호출하려는 시스템 콜의 번호를 전달합니다.
리눅스 커널의 [소스 코드][unistd-h-exit]에 따르면, `exit()` 시스템 콜에 해당하는 번호는 `93`입니다.

[unistd-h-exit]: https://github.com/torvalds/linux/blob/v6.13/include/uapi/asm-generic/unistd.h#L258

이 시스템 콜은 프로그램을 종료하며, [매뉴얼][man-exit]에 따르면 다음과 같은 프로토타입을 가집니다.

```c
void _exit(int status);
```

즉 첫 번째 인자로 종료 코드를 받습니다.
여기서 첫 번째 인자는 `a0` 레지스터로 전달합니다.
따라서 프로그램을 실행하면 종료 코드 `0`을 리턴하게 됩니다.

## 인사 메시지 보여주기

이제 빈 프로그램 대신 뭔가 하는 것을 만들어봅시다.
인사 메시지를 보여주는 프로그램을 `hello.S` 파일로 만들어보겠습니다.

먼저, 다음과 같이 스트링을 만듭니다.

```asm
  .data
msg:
  .asciz "Hello, world!\n"
  .set len, . - msg
```

첫 줄의 `.data` 지시자는 다음에 데이터가 온다고 어셈블러에게 알려줍니다.
앞서 `.text` 지시자와 비슷한 역할을 맡는데, 이런 것을 섹션<L>section</L>이라고 부릅니다.
이것이 중요한 이유는 프로그램을 만들 때 데이터와 인스트럭션이 메모리 상에서 구분되어 배치되어야 하기 때문입니다.
이에 대한 자세한 내용은 곧 만나볼 것입니다.

그 다음, 콜론으로 끝나는 `msg:`와 같은 것은 레이블<L>label</L>이라고 부릅니다.
이후 어셈블러는 레이블을 만나면, 그 이름에 해당하는 주소 값으로 대체합니다.
`.asciz` 지시자는 널 문자로 끝나는 스트링이라고 알려줍니다.

마지막에 `.set` 지시자는 상수를 만들어서 어셈블러에게 알려줍니다.
이후 어셈블러는 `len`을 만나면 상수 값으로 대체합니다.
`len`의 값은 앞서 만든 스트링의 길이가 되는데, 그 이유는 나중에 볼 것입니다.

위 코드에 이어서, 다음과 같이 엔트리 포인트를 작성합니다.

```asm
  .text
  .align 2

  .global _start
_start:
```

이 부분은 계속해서 사용할 것이기 때문에 앞으로는 설명을 생략하겠습니다.
이어서 다음과 같이 작성합니다.

```asm
  /* write(stdout, msg, len) */
  li a0, 1
  la a1, msg
  li a2, len
  li a7, 64
  ecall
```

이 부분은 `msg` 스트링을 화면에 보여줍니다.

앞서 소개한 것처럼, `ecall`은 시스템 콜을 호출합니다.
쓰기 작업을 하는 `write()` 시스템 콜은 `64`번에 해당하므로, 이 번호가 `a7` 레지스터에 들어간 것입니다.

한편, [매뉴얼][man-write]에 따르면 `write()` 시스템 콜의 프로토타입은 다음과 같습니다.

```c
ssize_t write(int fd, const void buf[.count], size_t count);
```

이 함수는 세 개의 인자를 받습니다.

시스템 콜의 인자는 첫 번째부터 차례로 `a0`, `a1`, `a2` 레지스터에 들어가고, 각각의 의미는 위 프로토타입과 같습니다.
즉, `a0`에는 파일 디스크립터 `1`을 넘깁니다.
이것은 표준 출력이므로, 화면에 나타나게 됩니다.
`a1`과 `a2`에는 각각 스트링 주소와 그 길이를 넘깁니다.
여기서 `a1`에는 `la` 인스트럭션이 쓰였는데, 이것은 'Load Adress'로서 주소를 가져옵니다.

마지막으로, 프로그램을 종료하는 코드를 작성합니다.

```asm
  /* exit(0) */
  li a0, 0
  li a7, 93
  ecall
```

실행 파일을 만들고 실행하면, 다음과 같이 셸에 인사 메시지가 나타납니다.

```shellsession
$ gcc -nostdlib hello.S
$ ./a.out
Hello, world!
```

한번 `msg`를 다른 메시지로 수정해서 실행해보세요.



# 어셈블리어부터 실행까지의 과정

지금까지 작성한 코드가 어떻게 기계어로 만들어지고 실행되는지 좀더 자세히 살펴보겠습니다.
이를 통해 왜 앞서 어셈블리어를 그런 식으로 작성했는지 이해하게 됩니다.

물론 기계어를 직접 읽는 것은 어렵기 때문에, 어셈블리어로 복원해서 볼 것입니다.
이렇게 기계어를 반대로 어셈블리어로 번역하는 것을 디스어셈블링<L>disassembling</L>이라고 부릅니다.
이것은 여태까지 사용해온 크로스 컴파일러에 내장된 기능이기 때문에, 곧바로 해볼 수 있습니다.

## 어셈블링: 오브젝트 파일 만들기

앞서 어셈블리어를 바로 실행 파일로 옮겼지만, 내부적으로는 좀더 세분화된 단계가 있습니다.
첫 번째로 거치는 과정은 어셈블링<L>assemble</L>이라고 부르며, 다음과 같이 `-c` 옵션으로 실행할 수 있습니다.

```shellsession
$ gcc -nostdlib -c hello.S
```

이 커맨드가 만드는 `hello.o` 파일은 오브젝트<L>object</L> 파일이라고 부릅니다.
실행 파일은 아니지만, 부분적으로 완성된 실행 파일처럼 생각해볼 수 있습니다.

## `text` 섹션 디스어셈블링

이 파일에 어떤 섹션이 있는지 확인해봅시다.

```shellsession
$ riscv64-linux-gnu-objdump -h hello.o
```

또는 다음과 같이 줄일 수도 있습니다.

```shellsession
$ alias objdump=riscv64-linux-gnu-objdump
$ objdump -h hello.o
```

여기서는 이렇게 줄여서 쓰겠습니다.

그 결과 중 일부분은 다음과 같습니다.

```shellsession
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000024  0000000000000000  0000000000000000  00000040  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         0000000f  0000000000000000  0000000000000000  00000064  2**0
                  CONTENTS, ALLOC, LOAD, DATA
```

`text`와 `data` 섹션이 들어있습니다.

이것이 과연 앞서 작성한 섹션일까요?
`text` 섹션에 무엇이 들어있는지 디스어셈블 해보겠습니다.

```shellsession
$ objdump -d -j .text hello.o
```

결과는 다음과 같습니다.

```shellsession
0000000000000000 <_start>:
   0:   00100513                li      a0,1
   4:   00000597                auipc   a1,0x0
   8:   0005b583                ld      a1,0(a1) # 4 <_start+0x4>
   c:   00f00613                li      a2,15
  10:   04000893                li      a7,64
  14:   00000073                ecall
  18:   00000513                li      a0,0
  1c:   05d00893                li      a7,93
  20:   00000073                ecall
```

왼쪽에는 주소와 함께 기계어가, 오른쪽에는 어셈블리어가 나옵니다.
이것은 실제로 작성했던 코드와 거의 일치합니다.
두 번째와 세 번째 줄, 즉 `aupic`와 `ld` 인스트럭션은 다른 부분인데, 실제로 작성했던 코드는 다음과 같은 `li` 인스트럭션입니다.

```asm
  li a1, msg
```

사실 `li` 명령은 프로세서가 이해할 수 있는 '진짜' 인스트럭션은 아닙니다.
편의를 위해 짧게 줄인 것을 어셈블리어 차원에서 제공한 것입니다.
이것은 수도 인스트럭션<L>pseudo-instruction</L>이라고 부릅니다.

이것 말고도 수도 인스트럭션은 꽤 많이 존재합니다.
여기서는 필요한 경우가 아니라면 이 두 가지를 굳이 구분하지 않고 사용할 것입니다.

## `data` 섹션 디스어셈블링

비슷한 방법으로 `data` 섹션의 내용도 볼 수 있습니다.

```shellsession
$ objdump -d -j .data hello.o
```

결과는 다음과 같습니다.

```shellsession
0000000000000000 <msg>:
   0:   6c6c6548                .word   0x6c6c6548
   4:   77202c6f                .word   0x77202c6f
   8:   646c726f                .word   0x646c726f
   c:   0a21                    .short  0x0a21
        ...
```

여기서 첫 번째 줄의 `6c6c6548`에 주목해봅시다.
이것은 네 개의 바이트<L>byte</L>를 차지하는 값이며, `48`, `65`, `6c`, `6c`가 차례로 기록된 것입니다.
RISC-V 아키텍처는 리틀 엔디안<L>little-endian</L>을 따르기 때문입니다.

이 부분을 이해하려면, 먼저 값<L>value</L>과 표현<L>representation</L>은 분리되어 있다는 사실부터 설명해야 합니다.
즉 숫자로서의 값 $42$은 메모리 상에서 표현된 것과 무관한 것입니다.
메모리는 값을 정확하게 기록할 수 있다면, 메모리 상에서 어떤 표현을 갖든지 상관이 없기 때문입니다.

반대로 말하면, 메모리에 `1001`라는 표현이 들어있다고 해서, 이것이 바로 이진수 $1001_{(2)}$에 해당하는 값인지는 알 수 없는 것입니다.
예를 들어, 2의 보수에 따르면 이 값은 $-7$을 나타낼 수도 있습니다.
즉 표현 자체는 값과 무관하며, 그것을 읽는 방법이 값을 정합니다.

한편, RISC-V 아키텍처에서 메모리는 바이트마다 순번이 매겨져있다고 가정합니다.
즉 바이트를 메모리의 최소 단위로 보는 것입니다.
이러한 메모리를 바이트 어드레서블<L>byte addressable</L>하다고 부릅니다.
(다른 여러 아키텍처 또한 이러한 메모리를 다룹니다.)

그리고 RISC-V에서는 4 바이트를 워드<L>word</L>라고도 부릅니다.
(물론 다른 여러 아키텍처도 그렇습니다.)
리틀 엔디안은 어떤 표현이 있을 때, 오른쪽에 와야할 바이트부터 낮은 메모리 주소에 먼저 두는 방식입니다.
예를 들어, 표현 `12345678`을 메모리 주소 상 `0`번에 둬야한다고 해봅시다.
그러면 오른쪽 `78`부터 두기 때문에, 메모리에는 `0`번부터 `3`번까지 차례로 `78`, `56`, `34`, `12`가 기록됩니다.

(그림 2)

RISC-V 아키텍처는 리틀 엔디안을 따르기 때문에, 앞서 첫 번째 줄의 `6c6c6548`은 차례로 `48`, `65`, `6c`, `6c`를 기록한 것입니다.
여기서 문자 값을 얻기 위해 아스키<L>ASCII</L> 코드로 변환해보면, 앞서 입력했던 스트링이 그대로 들어있음을 알 수 있습니다.

(그림 3)
```
0           4           8           c
48 65 6c 6c 6f 2c 20 77 6f 72 6c 64 21 0a 00 00
H  e  l  l  o  ,     w  o  r  l  d  !  \n \0 \0
```

앞서 `text` 섹션에서 다음 네 번째 인스트럭션을 주목해봅시다.

```shellsession
   c:   01200613                li      a2,15
```

이것은 원래 소스 코드에서 다음과 같았습니다.

```asm
  li a2, len
```

즉 어셈블러가 `len` 상수를 `15`로 계산한 것입니다.
이 상수는 앞서 다음과 같이 만들었습니다.

```asm
  .data
msg:
  .asciz "Hello, world!\n"
  .set len, . - msg
```

여기서 점 기호 `.`은 현재 주소를 의미합니다.
앞서 본 것처럼 `msg` 스트링을 위해 15 바이트를 할당했기 때문에, 이후 주소는 상대적으로 15 바이트만큼 큰 값이 됩니다.
따라서 `len`은 그 주소의 차이로서, 자연스럽게 문자열의 길이가 됩니다.

## 링킹: 실행 파일 만들기

앞서 만든 오브젝트 파일의 디스어셈블링 결과를 보면, 각 섹션은 메모리 주소 `0`번 부터 시작합니다.
사실 이것은 정확한 주소가 정해지지 않은 것입니다.
나중에 실행 파일을 만드는 과정에서 구체적인 주소로 옮겨지는데, 이것을 리로케이션<L>relocation</L>이라고 부릅니다.

오브젝트 파일에는 리로케이션의 대상이 들어있습니다.
이것은 다음과 같이 확인할 수 있습니다.

```shellsession
$ objdump -r hello.o
```

결과 중 일부를 보면 `msg` 레이블을 포함하고 있습니다.

```shellsession
RELOCATION RECORDS FOR [.text]:
OFFSET           TYPE              VALUE
0000000000000004 R_RISCV_GOT_HI20  msg
```

오브젝트 파일에서 실행 파일을 만드는 과정을 링킹<L>linking</L>이라고 부르고, 그 역할을 맡는 프로그램을 링커<L>linker</L>라고 부릅니다.
다음과 같이 링커를 이용해 오브젝트 파일로부터 실행 파일을 만듭시다.

```shellsession
$ riscv64-linux-gnu-ld hello.o
```

앞서 `gcc`로 한번에 실행 파일을 만든 것은 어셈블링과 링킹을 거친 것과 같습니다.
이렇게 만든 실행 파일 또한 똑같은 결과를 보여줍니다.

```shellsession
$ ./a.out
Hello, world!
```

여기서 `text` 섹션의 메모리 주소는 어떨까요?
실행 파일을 디스어셈블 해봅시다.

```shellsession
$ objdump -d -j .text --no-show-raw-insn a.out
```

그러면 다음과 같은 부분이 나타납니다.

```shellsession
0000000000010120 <_start>:
   10120:       li      a0,1
   10124:       auipc   a1,0x2
   10128:       ld      a1,-316(a1) # 11fe8 <_GLOBAL_OFFSET_TABLE_+0x8>
   1012c:       li      a2,15
   10130:       li      a7,64
   10134:       ecall
   10138:       li      a0,0
   1013c:       li      a7,93
   10140:       ecall
```

즉 엔트리 포인트가 구체적인 주소로 특정된 것입니다.
이와 같이 `data` 섹션도 확인해보시기 바랍니다.

섹션의 시작 주소는 다음과 같은 방법으로도 볼 수 있습니다.

```shellsession
$ objdump -h a.out
```

결과는 다음과 비슷할 것입니다.
여기서 메모리 주소인 `VMA` 항목에 주목해보시기 바랍니다.

```shellsession
Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000024  0000000000010120  0000000000010120  00000120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .got          00000010  0000000000011fe0  0000000000011fe0  00000fe0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .got.plt      00000010  0000000000011ff0  0000000000011ff0  00000ff0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         0000000f  0000000000012000  0000000000012000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, DATA
```

`text` 섹션과 `data` 섹션이 메모리 상 구분되어 있습니다.

실행 파일을 실행하면, 로더<L>loader</L>라는 프로그램이 각 섹션을 메모리에 올립니다.

(그림 4: 메모리 레이아웃)

이때 실행 파일에는 로더가 참고할 메타 데이터를 포함하고 있어야 합니다.
리눅스에서 사용하는 대표적인 실행 파일 형태는 ELF 파일입니다.
따라서 `readelf` 프로그램으로 메타 데이터를 볼 수 있습니다.

```shellsession
$ riscv64-linux-gnu-readelf -h a.out
```

결과의 일부를 가져오면 다음과 같습니다.

```shellsession
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           RISC-V
  Version:                           0x1
  Entry point address:               0x10120
```

엔트리 포인트 주소를 비롯해 다양한 정보가 나타납니다.
로더는 이 정보를 이용해 프로그램을 메모리에 옮기고, 엔트리 포인트부터 명령을 실행하게 됩니다.

## 프로그램 실행 과정

이렇게 메모리에 올라온 프로그램은 구체적으로 어떻게 실행될까요?

다음에 수행할 인스트럭션의 주소는 프로그램 카운터라고 부르는 레지스터가 기억합니다.
결론적으로, 컴퓨터가 하는 일은 다음 과정을 단순히 반복하는 것입니다.

1. 프로그램 카운터의 주소를 확인해서 인스트럭션을 가져온다.
1. 그 인스트럭션을 실행한다.
1. 프로그램 카운터의 값을 증가시킨다.

예를 들어, 앞서 디스어셈블한 결과를 다시 가져와봅시다.

```shellsession
0000000000010120 <_start>:
   10120:       li      a0,1
   10124:       auipc   a1,0x2
   10128:       ld      a1,-316(a1) # 11fe8 <_GLOBAL_OFFSET_TABLE_+0x8>
   1012c:       li      a2,15
   10130:       li      a7,64
   10134:       ecall
   10138:       li      a0,0
   1013c:       li      a7,93
   10140:       ecall
```

RISC-V 아키텍처는 인스트럭션이 4 바이트이므로, 프로그램 카운터 또한 `4`씩 증가하게 됩니다.
따라서 프로그램 카운터는 엔트리 포인트의 주소인 `10120`부터 시작해, 프로세서는 각 인스트럭션을 순차적으로 실행하게 됩니다.



# 변수 구현하기

C 언어는 아키텍처와 무관하게 쓸 수 있는 고수준 언어인 반면, 어셈블리어는 그렇지 않습니다.
반대로 말하면, 컴파일러는 C 언어를 어셈블리어로 컴파일하는 과정을 반드시 거치게 됩니다.

가상의 C 언어 코드를 어셈블리어로 옮겨보며, 어떻게 어셈블리어가 고수준 언어의 기능을 만들어내는지 살펴보겠습니다.
그 첫 단계로서, 다음과 같은 전역 `int` 변수를 만드는 것이 목표입니다.

```c
int foo = 42;
```

## 초기화

변수는 메모리 공간의 할당입니다.
따라서 어셈블리어를 통해 `int` 변수는 `data` 섹션에서 다음과 같이 만들 수 있습니다.

```asm
  .data
foo:
  .word 42
```

`.word` 지시자는 워드의 크기인 4 바이트만큼 메모리를 차지하도록 만듭니다.
여기서 `int` 타입은 4 바이트라고 가정합니다.

결과를 보기 위해, 종료 코드를 변수의 값으로 리턴해봅시다.
이전과 같이 `text` 섹션에 엔트리 포인트를 직접 만들어보시기 바랍니다.
그 아래에 코드를 작성합니다.

```asm
_start:
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

`lw` 인스트럭션은 'Load Word'로서, `a0` 레지스터에 `foo` 값을 워드 크기로 가져와 넣습니다.
그리고 이전과 같이 `exit()` 시스템 콜을 호출합니다.

실행하면 종료 코드는 다음과 같이 `42`가 나타나게 됩니다.

```shellsession
$ gcc -nostdlib int.S
$ ./a.out
$ echo $?
42
```

`foo`의 값을 바꿔서 실행해보세요.

## 실제 컴파일과 비교하기

정말로 컴파일러가 변수를 이런 식으로 컴파일할까요?
C 언어로 작성해서 컴파일 결과를 살펴보겠습니다.
다음을 `int_c.c` 파일로 만들어봅시다.

```c
int foo = 42;

int main(void) {
  return 0;
}
```

이것을 다음과 같이 컴파일합니다.
여기서 컴파일이란 C 언어를 어셈블리로 옮기는 과정을 말합니다.

```shellsession
$ gcc -nostdlib -S int_c.c
```

그러면 `int_c.s` 어셈블리 파일이 만들어집니다.
그 내용 중에는 다음과 같은 것을 발견할 수 있습니다.

```asm
foo:
  .word 42
```

이것은 직접 작성했던 어셈블리어와 같습니다.



# 다른 정수 타입 구현하기

앞서 `int` 타입을 구현했듯이, 여기서는 다른 크기의 타입도 만들어보겠습니다.
여기서는 다음과 같은 코드가 목표입니다.

```c
char foo = 42;
short bar = 99;
long baz = 1;
```

그리고 종료 코드로 결과를 리턴하는 것 대신, C 언어 라이브러리인 `printf()` 함수를 이용할 것입니다.
따라서 C 언어와 어셈블리를 함께 쓰는 방법을 알아볼 것입니다.

이어서 다른 메모리 크기를 사용했을 때 나타나는 메모리 문제도 살펴봅니다.
이를 통해 앞서 사용한 `.align` 지시자가 왜 필요한지 설명할 것입니다.

## C 언어와 연동

C 언어에서 `char` 타입은 1 바이트입니다.
여기서 `short` 타입과 `long` 타입이 각각 2 바이트와 8 바이트라고 해봅시다.
그러면 `int` 타입과 비슷하게 만들 수 있습니다.
다음을 `types.S` 파일로 만들어봅시다.

```asm
  .data
baz:
  .dword 1
bar:
  .half 99
foo:
  .byte 42
```

[매뉴얼][gnu-as-riscv]에 따르면, RISC-V 어셈블리어에서 `.dword`, `.half`, `.byte` 지시자는 각각 8, 2, 1 바이트에 해당합니다.

[gnu-as-riscv]: https://sourceware.org/binutils/docs/as/RISC_002dV_002dDirectives.html 

여기서는 C 언어 라이브러리의 `printf()` 함수로 값을 출력해봅시다.
C 코드에게 위 변수 이름을 알려주기 위해, 다음 줄을 추가합니다.

```asm
  .global baz
  .global bar
  .global foo
```

이어서 `types.c` 파일을 만들어봅시다.

```c
#include <stdio.h>

extern char foo;
extern short bar;
extern long baz;

int main(void) {
  printf("foo: %d, bar: %hd, baz: %ld\n", foo, bar, baz);
  return 0;
}
```

여기서 `extern` 키워드는 다른 파일에서 정의한 변수를 사용하도록 만듭니다.

다음과 같이 컴파일합니다.

```shellsession
$ gcc types.c types.S
```

실행하면 다음과 같습니다.

```shellsession
$ ./a.out
foo: 42, bar: 99, baz: 1
```

한번 `long` 타입으로 선언했던 변수를 `char` 타입으로 바꿔서 사용해보세요.
어셈블리어에는 기본적으로 타입이라는 개념이 없으므로, 그러한 동작을 막지 않습니다.
즉, 어셈블리어는 타입을 관리할 책임이 프로그래머에게 있습니다.

## 메모리 얼라인먼트

앞서 어셈블리어 코드에서, 가장 큰 메모리 크기인 `.dword` 지시자부터 사용한 이유가 있습니다.
그 이유를 알아보기 위해, 이번에는 반대로 작성해봅시다.

```asm
  .data
foo:
  .byte 42
bar:
  .half 99
baz:
  .dword 1
```

이것을 어셈블링만 거쳐보겠습니다.

```shellsession
$ gcc -nostdlib types.S -c
```

그리고 `data` 섹션을 디스어셈블 해봅시다.

```shellsession
$ objdump -d -j .data --no-show-raw-insn types.o
```

그러면 결과는 다음과 같습니다.

```shellsession
0000000000000000 <foo>:
   0:   .word   0x0100632a

0000000000000001 <bar>:
   1:   .word   0x00010063

0000000000000003 <baz>:
   3:   .word   0x00000001
   7:   .word   0x00000000
```

`bar`와 `baz` 변수의 메모리 주소는 홀수입니다.

보통 어셈블리어에서 데이터의 주소를 홀수로 두는 것은 좋지 않습니다.
아키텍처에 따라 그런 데이터의 접근을 지원하지 않을 수도 있고, 지원하더라도 성능 상 불이익을 갖게 됩니다.
[매뉴얼][riscv-isa-man]에 따르면, RISC-V 아키텍처에서도 지원은 보장되지 않습니다.
여기서 자세히 다루지는 않겠지만, 이러한 한계는 하드웨어 구현 상 어려움에서 옵니다.

다른 여러 아키텍처와 마찬가지로, RISC-V 아키텍처의 [매뉴얼][riscv-prog-man]에서 권고하는 것은 '읽기 좋은' 메모리 주소에 두는 것입니다.
예를 들어 2 바이트의 크기라면, 주소를 2 바이트의 배수로 맞추는 것입니다.
이처럼 데이터가 $n$ 바이트일 때, $n$ 바이트의 배수인 주소를 데이터의 내츄럴 바운더리<L>natural boundary</L>라고 부릅니다.
그리고 그 주소에 맞춘 것을 얼라인<L>aligned</L> 되었다고 부릅니다.


`.align` 지시자를 이용해 올바른 코드로 고쳐보겠습니다.

```asm
  .data
foo:
  .byte 42
  # [!code ++:1]
  .align 1
bar:
  .half 99
  # [!code ++:1]
  .align 3
baz:
  .dword 1
```

여기서 `.align` 지시자에 오는 숫자는 2의 지수라는 점을 참고하세요.
즉 `bar`의 주소는 2 바이트로, `baz`의 주소는 8 바이트로 얼라인됩니다.

이렇게 수정한 코드를 아까와 같이 디스어셈블 해서 실제로 메모리에 어떻게 위치하는지 확인해보세요.

한편, 앞서 `data` 섹션에서도 이러한 지시자를 사용했습니다.

```asm
  .text
  .align 2
```

이렇게 인스트럭션을 얼라인하는 것은, RISC-V 아키텍처의 요구 사항이기 때문입니다.



# 덧셈 구현하기

변수를 구현했으니, 다음과 같은 덧셈을 만들어봅시다.

```c
int foo = 42;

int main(void) {
  return foo + 99;
}
```

RISC-V 아키텍처에는 덧셈 인스트럭션이 있기 때문에 바로 만들 수 있습니다.

## 어셈블리어로 옮기기

앞서 `int.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`add.S` 파일을 만들어서 엔트리 포인트를 작성합니다.

```asm
_start:
  /* exit(foo + 99) */
  lw a0, foo
  addiw a0, a0, 99
  li a7, 93
  ecall
```

`lw` 인스트럭션으로 `foo` 값을 가져오고, `addiw` 인스트럭션으로 `99`를 더합니다.
덧셈 결과인 `141`는 곧 종료 코드가 됩니다. (확인해보세요.)

## 인스트럭션 디코딩

프로세서는 인스트럭션을 실행한다고 했습니다.
여기서는 `addiw` 인스트럭션이 어떻게 실행되는지 알아보겠습니다.
이를 통해 RISC-V 기계어가 어떻게 구성되는지 알게 될 것입니다.

먼저, 모든 RISC-V 인스트럭션은 가장 오른쪽 7 비트에 opcode 필드를 갖고 있는데, 인스트럭션의 종류를 알려줍니다.
그리고 `addiw` 인스트럭션은 다음 형태를 갖고 있습니다.

(그림)
```text
immediate rs1 funct3 rd opcode
imm[11:0] rs1    000 rd 0011011
12 bit   5bit  3bit 5bit 7bit
```

여기서 3 비트의 funct3 필드는 opcode 필드과 함께 인스트럭션의 종류를 나타냅니다.
즉 프로세서는 이 두 필드를 읽어서 `addiw` 인스트럭션이라는 것을 알게됩니다.

RISC-V 아키텍처에서 인스트럭션은 32 비트이므로, 남은 비트는 22 비트입니다.
그 중에 5 비트의 rd 필드는 결과가 담길 레지스터를 가리킵니다.
레지스터가 5 비트로 표현되기 때문에, 총 32 개의 레지스터를 가리킬 수 있게 됩니다.
이와 같이, rs1 필드는 덧셈할 값이 담긴 레지스터를 가리킵니다.
마지막으로 남은 immediate 필드에는 값이 직접적으로 담깁니다.
이렇게 명령어에 직접 담긴 값을 이미디에이트<L>immediate</L> 값이라고 부릅니다.

원래의 인스트럭션은 다음과 같습니다.

```asm
  addiw a0, a0, 99
```

여기서 `a0` 레지스터는 10 번 레지스터에 해당한다는 사실을 이용하면, 이것이 기계어로 어떻게 바뀔지 예상해볼 수 있습니다.
10은 2진법으로 `1010`, 99는 `1100011`이므로 다음과 같습니다.

(그림)
```
000001100011 01010 000 01010 0011011

0000 0110 0011 0101 0000 0101 0001 1011
   0    6    3   5     0    5   1     b
```

그러면 16진법으로 표현하면 `0635051b`를 얻습니다.

이것을 디스어셈블링을 통해 확인해봅시다.

```shellsession
$ gcc -nostdlib -c add.S
$ objdump -d -j .text add.o
```

결과 중에 다음이 나타날 것입니다.

```shellsession
   8:   0635051b                addiw   a0,a0,99
```

왼쪽의 기계어가 예상했던 결과가 일치합니다.

## 뺄셈

그렇다면 뺄셈은 어떻게 만들 수 있을까요?
다음을 어셈블리어로 만들어보세요.

```c
int foo = 42;
int main(void) {
  return 99 - foo;
}
```

RISC-V 어셈블리어에는 뺄셈 인스트럭션이 있습니다.

```text
sub rd, rs1, rs2
```

이 인스트럭션은 `rs1`에서 `rs2`를 뺀 것을 `rd`에 넣습니다.
여기에는 이미디에이트 값을 쓰지 않기 때문에, 두 개의 레지스터를 사용해야 합니다.



# 할당 구현하기

앞서 메모리의 값을 레지스터에 가져오는 `lw` 인스트럭션을 사용했습니다.

```asm
  lw a0, foo
```

이번에는 반대로 레지스터의 값을 메모리에 써보겠습니다.
이를 통해 다음과 같은 할당 연산자를 구현해볼 것입니다.

```c
int foo = 42;

int main(void) {
  foo = 99;
  return foo;
}
```

RISC-V 어셈블리어에는 이를 위한 `sw` 인스트럭션이 있으므로, 바로 만들어볼 수 있습니다

## 어셈블리어로 옮기기

앞서 `add.S` 파일과 마찬가지로 `foo` 변수를 이용합니다.
`assign.S` 파일을 만들어서 엔트리 포인트를 작성합니다.

```asm
_start:
  /* foo = 99 */
  la a0, foo
  li a1, 99
  sw a1, 0(a0)
```

`a0` 레지스터는 `foo`의 주소를, `a1` 레지스터에는 `99`를 넣습니다.
그리고 `sw` 인스트럭션은 'Store Word'로서, `a1` 레지스터의 값을 워드로서 메모리에 넣습니다.
그 주소는 `a0` 레지스터의 값을 사용하며, `0`은 그로부터 얼마나 떨어진 곳인지를 지정하는 값입니다.

이어서 다음과 같이 `foo`의 값을 종료 코드로 리턴합니다.

```asm
  /* exit(foo) */
  lw a0, foo
  li a7, 93
  ecall
```

실행하면 `99`를 종료 코드로 리턴할 것입니다.

메모리로부터 값을 가져오는 방법과, 메모리에 값을 넣는 방법을 알아보았습니다.
여기까지의 내용을 응용해서, 다음을 어셈블리어로 만들어보시기 바랍니다.

```c
int foo = 42;

int main(void) {
  foo++;
  return foo;
}
```

앞서 만든 `assign.S` 파일을 `inc.S` 파일로 복사해보세요.
약간의 수정을 통해 해결할 수 있습니다.



# 조건문 구현하기

TODO



# 마치며

본문의 소스 코드는 [깃허브][gh]<L>GitHub</L>에서 확인할 수 있습니다.

[gh]: https://github.com/wcho21/langwalk/tree/main/riscv

## 레퍼런스

- [*The RISC-V Reader*][riscv-reader]: RISC-V 아키텍처의 간략한 소개>
- [*An Introduction to Assembly Programming with RISC-V*][intro-asm-riscv]: RISC-V 어셈블리어 프로그래밍 소개.
- [*The RISC-V Instruction Set Manual*][riscv-isa-man]: RISC-V 인스트럭션 매뉴얼.
- [*RISC-V Assembly Programmer's Manual*][riscv-prog-man]: 
- [*RISC-V ABIs Specification*][riscv-abi]
- [*Using `as`*][gnu-as]: GNU 어셈블러 `as` 매뉴얼.
- [*Options for Linking*][gcc-opt-link], [*RISC-V Options*][gcc-opt-riscv]: GNU 컴파일러 `gcc` 매뉴얼.
- [`exit()`][man-exit], [`write()`][man-write]: 시스템 콜 매뉴얼.
- [`unistd.h`][unistd-h]: 리눅스 커널 시스템 콜 헤더 파일.

더 자세한 내용이 궁금하다면 다음 자료를 참고해볼 수 있습니다.

- *Computer Organization and Design (RISC-V Edition)* (David Patterson, John Hennessy, 2020), 또는 *컴퓨터 구조 및 설계 RISC-V* (한티미디어, 2022): RISC-V 인스트럭션의 하드웨어 구현을 자세히 소개.
- *The Art of ARM Assembly, Volume 1* (Randall Hyde, 2025): ARM 아키텍처 어셈블리어 프로그래밍 소개. 어셈블리어에서 나타나는 공통적인 컨셉을 살펴볼 수 있습니다.

[riscv-reader]: http://riscvbook.com/korean/risc-v-reader-korean-v1p0.pdf
[intro-asm-riscv]: https://riscv-programming.org/book/riscv-book.html
[riscv-isa-man]: https://github.com/riscv/riscv-isa-manual/releases/tag/20250508
[riscv-prog-man]: https://github.com/riscv-non-isa/riscv-asm-manual/releases/tag/v0.0.1
[riscv-abi]: https://github.com/riscv-non-isa/riscv-elf-psabi-doc/releases/tag/v1.0
[gnu-as]: https://sourceware.org/binutils/docs/as/
[gcc-opt-link]: https://gcc.gnu.org/onlinedocs/gcc-14.3.0/Link-Options.html
[gcc-opt-riscv]: https://gcc.gnu.org/onlinedocs/gcc-14.3.0/RISC-V-Options.html
[man-exit]: https://man7.org/linux/man-pages/man2/_exit.2.html
[man-write]: https://man7.org/linux/man-pages/man2/write.2.html
[unistd-h]: https://github.com/torvalds/linux/blob/v6.13/include/uapi/asm-generic/unistd.h




