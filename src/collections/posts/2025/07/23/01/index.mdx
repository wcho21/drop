---
title: "C 언어 프로그래밍 시작하기"
date: 2025-07-23T01:00:00+09:00
summary: "간단한 프로그램을 만들며 배워보는 문법과 메모리 동작"
thumbnail: "/src/assets/thumbnails/2025/07/23/01/thumbnail.webp"
series: "프로그래밍 언어 산책"
---

import L from "@/components/post/AltLang.astro";
import P from "@/components/post/pseudocode";
import Figure from "@/components/post/Figure.astro";
import FigureCaption from "@/components/post/FigureCaption.astro";
import FigureDisplay from "@/components/post/FigureDisplay.astro";
import Quote from "@/components/post/Quote.astro";

import fig1 from "./figs/fig1.jpg";
import fig2 from "@texfigs/2025/07/23/01/fig2.svg";
import fig3 from "@texfigs/2025/07/23/01/fig3.svg";
import fig4 from "@texfigs/2025/07/23/01/fig4.svg";
import fig5 from "@texfigs/2025/07/23/01/fig5.svg";
import fig6 from "@texfigs/2025/07/23/01/fig6.svg";
import fig7 from "@texfigs/2025/07/23/01/fig7.svg";

<Quote>
  새 프로그래밍 언어를 배우는 유일한 방법은 프로그램을 만들어보는 것이다.

  <p slot="detail">The only way to learn a new programming language is by writing programs in it.</p>

  <p slot="name">-- *The C Programming Language* (1988)</p>
</Quote>



역사상 가장 영향력 있는 프로그래밍 언어를 고른다면, 아마도 C 언어가 빠질 수는 없을 것입니다.
[어느 통계][so-lang]에 따르면, 오늘날에는 파이썬<L>Python</L>과 같은 언어로 프로그래밍을 시작하는 경우가 많다고 하지만, C 언어는 여전히 배울만한 가치가 있습니다.
왜일까요?

[so-lang]: https://survey.stackoverflow.co/2024/technology#most-popular-technologies-language-learn

1. C 언어는 문법이 간단해서 배워야할 양이 비교적 적습니다.
2. C 언어는 컴퓨터의 내부 동작을 이해하기에 좋은 언어입니다.

파이썬과 같은 프로그래밍 언어는 사람에게 친화적이도록 보이기 위해 컴퓨터의 자세한 내부 동작을 감추고 있습니다.
이것은 프로그래밍 자체를 빨리 시작하는데에 도움을 주지만, 더 나아가 내부 동작을 알고자 한다면 학습을 막는 요소가 되기도 합니다.

반면, C 언어는 그러한 부분을 그대로 드러내기 때문에, 작성하는 코드가 컴퓨터에 구체적으로 무엇을 시키는지 알 수 있습니다.
그리고 그렇게 되면 다른 프로그래밍 언어에서 감춰둔 요소를 볼 수 있게 되기도 합니다.

앞으로의 내용에서 이러한 C 언어를 살펴볼 것입니다.
모든 내용을 다루지는 않겠지만, 간단한 할 일 관리 프로그램을 만들어보며 문법을 단계적으로 만나게 될 것입니다.
그와 동시에 컴퓨터의 메모리에 어떤 일이 발생하는지 또한 시각적으로 알아보겠습니다.

C 언어를 배우기 위해 필요한 것은 C 언어로 프로그램을 만들기 위한 C 컴파일러<L>compiler</L>와, 이것을 실행하기 위한 Bash 셸<L>shell</L>입니다.
이런 프로그램의 설치 방법은 여기서 다루지 않지만, 본문의 예시 코드가 있는 [깃허브][gh]<L>GitHub</L>의 설명을 참고해볼 수 있습니다.

앞으로의 내용은 `gcc`라는 C 컴파일러로 진행합니다.
아래와 비슷하게 버전이 나타난다면 설치된 것입니다.

```shellsession
$ gcc --version 
gcc (Ubuntu 14.2.0-4ubuntu2) 14.2.0
Copyright (C) 2024 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
```

여기서는 C 언어를 사용해본 경험이 없다고 가정하고 설명합니다.
그렇지만 C 언어가 아니더라도 프로그래밍을 해본 경험이 있다면, 내용을 좀더 수월하게 이해하는데 도움이 될 것입니다.
그러면 시작해봅시다.



# 첫 프로그램 만들기

이 글의 목표는 C 언어로 간단한 할 일 관리 프로그램을 만드는 것입니다.
완성된 모습은 다음과 같습니다.

먼저, 다음과 같이 할 일을 추가할 수 있습니다.

```shellsession
$ todo add "Learn C"
Added task 'Learn C'.
$ todo add "Get a coffee"
Added task 'Get a coffee'.
```

그리고 그 목록을 보는 것도 할 수 있습니다.

```shellsession
$ todo list
1: Learn C      To-do
2: Get a coffee To-do
```

앞으로 살펴볼 내용은 이러한 프로그램을 만들기 위해 필요한 것들입니다.
그 첫 단계로서, C 언어로 어떻게 프로그램을 만들 수 있는지 봅시다.

## 빈 프로그램 만들기

처음에 만들 가장 간단한 프로그램은 빈 프로그램입니다.
아무것도 하지 않겠지만 어쨌든 프로그램이긴 합니다.
이런 것을 만드는 이유는, C 언어로 프로그램을 만드는 과정을 보기 위함입니다.

다음 내용을 `todo.c` 파일로 만듭시다.

```c
int main(void) {
  return 0;
}
```

이것은 `main()` 함수를 만든 것인데, 함수란 무엇인지는 나중에 알아보겠습니다.
중요한 것은, C 프로그램은 항상 이 함수부터 시작한다는 사실입니다.

이 함수가 하는 일은 말 그대로 숫자 0을 돌려주는 것입니다.

```c
  return 0;
```

수학적인 함수로 말하자면, 항상 $0$을 가지는 $f(x) = 0$와 같습니다.
다만 괄호 안에 사용한 `void` 키워드는 이 함수의 파라미터가 없다는 표현입니다.
그러니 $f = 0$라고 쓰는 것이 더 정확할지도 모릅니다.
물론 수학의 함수는 C 언어의 함수와는 다소 차이가 있으니, 어디까지나 이해를 돕기위한 비유입니다.

이제 C 코드로 작성한 `todo.c` 파일을 프로그램으로 만들 차례입니다.
이것을 컴파일<L>compile</L>한다고 부르고, 그것을 하는 프로그램을 컴파일러<L>compiler</L>라고 부릅니다.
즉 프로그램으로 프로그램을 만드는 것입니다.

컴파일러에는 여러 종류가 있지만, 여기서는 대표적인 컴파일러인 GCC 컴파일러를 사용합니다.
다음과 같이 컴파일을 시킬 수 있습니다.

```shellsession
$ gcc todo.c
```

그러면 기본적으로 `a.out` 파일이 만들어지고, 실행할 수 있으므로 실행 파일<L>executable</L>이라고 부릅니다.

이것을 실행해봅시다.

```shellsession
$ ./a.out
```

어떤 일이 일어날까요?
정말로 아무 일도 일어나지 않습니다. (확인해보세요.)

이 이름이 마음에 들지 않는다면, 다음과 같이 이름을 지어줄 수도 있습니다.

```shellsession
$ gcc -o todo todo.c
$ ./todo
```

그런데 돌려준다고 언급했던 `0`은 어디로 갔을까요?
다음과 같이 종료 코드<L>exit code</L>로 확인할 수 있습니다.

```shellsession
$ echo $?
0
```

Bash 셸에서는 방금 얻은 종료 코드를 `$?` 변수에 기억합니다.
이 종료 코드가 무슨 의미인지는 나중에 보겠습니다.
지금은 `main()` 함수가 돌려준 값이라고 이해하고 넘어가겠습니다.

그런데 이것이 정말로 `main()` 함수에서 돌려준 값일까요?
한번 `main()` 함수가 다른 값을 돌려주도록 바꿔서 실행해보세요.

```c
int main(void) {
  // [!code --]
  return 0;
  // [!code ++]
  return 1;
}
```

컴파일과 실행은 다음과 같이 한 줄로 실행할 수도 있습니다.

```shellsession
$ gcc -o todo todo.c && ./todo
$ echo $?
1
```

또 하나의 팁으로서, 셸에서 <kbd>Ctrl</kbd> + <kbd>P</kbd> 혹은 <kbd>⬆︎</kbd> 방향키를 눌러 방금 실행한 명령어를 가져올 수 있습니다.

다른 종료 코드로 바꿔서 한번 컴파일 해보세요.
앞으로 컴파일이라고 하면 이런 과정을 말하는 것이고, 똑같은 설명은 반복적이므로 생략하겠습니다.
연습이 끝났으면 종료 코드를 `0`으로 되돌려놓고 진행합니다.

## 컴파일러의 역할

그런데 컴파일러가 왜 필요한 것일까요?

사실 컴퓨터는 앞서 작성한 C 언어를 이해할 수 없습니다.
C 언어는 사람을 위한 인공적인 언어일 뿐입니다.
따라서 이것을 '컴퓨터가 이해하는 명령'으로 바꿀 필요가 있는데, 컴파일러가 그 역할을 맡습니다.

여기서 '컴퓨터가 이해하는 명령'이라는 게 정확히 무엇일까요?
컴파일한 결과를 직접 들여다보겠습니다.
다음과 같이 `-g` 옵션을 붙여서 컴파일해봅시다.

```shellsession
$ gcc -o todo -g todo.c
```

그러면 `todo` 파일의 내용이 무슨 의미인지 볼 수 있습니다.

```shellsession
$ objdump --disassemble=main --source --section=.text todo
```

그 내용 일부는 다음과 비슷하게 나타날 것입니다. (구체적으로는 다를 수도 있습니다.)

```shellsession
int main(void) {
  return 1;
// [!code word:52800020]
 7a8:   52800020        mov     w0, #0x1                        // #1
// [!code word:d65f03c0]
 7ac:   d65f03c0        ret
```

이것이 무슨 의미인지는 다루지 않겠지만, 여기서 `52800020`, `d65f03c0` 같은 것이 컴퓨터가 직접 이해할 수 있는 명령입니다.
이것은 기계어<L>machine language</L>라고도 부르는데, 원칙적으로는 컴퓨터가 이것만 이해할 수 있습니다.

기계어를 처리하는 장치는 프로세서<L>processor</L>라고 부르고, 만드는 사람마다 자유롭게 디자인할 수 있으므로 다양한 종류가 존재합니다.
따라서 기계어 또한 다양한 종류가 나타나게 됩니다.

이로부터 다음과 같은 문제가 생깁니다.

1. 직접 기계어로 프로그래밍할 수도 있겠지만, 사람이 읽고 쓰며 이해하기에는 다소 어렵습니다.
1. 한 프로세서에 동작하는 프로그램을 만들었다고 하더라도, 다른 프로세서에서 동작하게 만들려면 다른 기계어로 다시 만들어야 합니다.

C 언어는 이러한 문제를 해결해줍니다.

1. 조금 더 인간에 가까운 언어로 프로그램을 작성할 수 있도록 도와줍니다.
   이런 언어를 고수준<L>high-level</L> 언어라고 부릅니다.
   반대로 기계에 가까울수록 저수준<L>low-level</L>이라고 부릅니다.
1. 프로세서의 종류를 신경 쓸 필요가 사라집니다.
   각 프로세서에서 동작하는 C 컴파일러를 한번 만들어두면, 그 프로세서에 맞는 기계어로 자동으로 바꿀 수 있기 때문입니다.

즉 컴파일러란 일종의 번역기와 같습니다.
컴파일러 입장에서 C 코드는 번역의 시작점이 되므로 소스 코드<L>source code</L>라고도 부릅니다.

## 코드 불러오기: `#include`

이제 빈 프로그램 대신, 실제로 뭔가 하는 것을 만들어봅시다.
여기서는 할 일을 이미 추가했다고 치고, 그 목록을 보여주는 부분부터 시작하겠습니다.

화면에 무언가를 보여줘야 하지만, C 언어 자체에는 그런 기능이 없습니다.
이러한 것은 미리 만들어둔 코드인 라이브러리<L>library</L>라는 이름으로 제공하는데, 다음과 같이 가져올 수 있습니다.

```c
// [!code ++:1]
#include <stdio.h>

int main(void) {
  // [!code ++:1]
  printf("1: Learn C\tTo-do\n");

  return 0;
}
```

컴파일하고 실행하면 다음과 같습니다.

```shellsession
1: Learn C      To-do
```

여기서 첫째 줄은 `stdio.h` 파일의 내용을 가져오라는 뜻입니다.

```c
#include <stdio.h>
```

이러한 파일을 헤더<L>header</L> 파일이라고 부르고, 여기에 `printf()` 함수가 있기 때문에 쓸 수 있습니다.
`stdio.h` 파일 이름부터 표준 입출력<L>standard input/output</L>의 줄임말입니다.
이처럼 유용한 함수가 포함된 헤더 파일을 라이브러리라고 부릅니다.
특히 `stdio.h` 헤더는 기본적으로 제공되는 표준 라이브러리입니다.

화면에 보여주는 일은 `printf()` 함수가 맡습니다.

```c
  printf("1: Learn C\tTo-do\n");
```

여기서 따옴표로 감싼 것을 문자열 또는 스트링<L>string</L>이라고 부릅니다.
이것 또한 앞서 사용한 숫자 `0`처럼, 앞으로 자주 사용할 종류입니다.
그리고 괄호와 함께 함수에게 일을 시키는 것을 호출<L>call</L>한다고 부르고, 이때 넘긴 값을 호출 인자<L>call arguments</L> 또는 간단히 인자라고 부릅니다.

중간에 쓰인 `\t`와 `\n`은 각각 탭 문자와 줄바꿈 문자를 가리킵니다.
만약 줄바꿈 문자를 다음과 같이 직접 쓴다면 어떻게 될까요?

```c
  // [!code error:2]
  printf("1: Learn C\tTo-do
  ");
```

이것은 문법 오류로 컴파일되지 않습니다. (한번 해보세요.)

따라서 `\n` 같은 식으로 입력하는데, 기존의 의미에서 '탈출'한 문자이기 때문에 이스케이프<L>escape</L> 문자라고도 부릅니다.

한편, 같은 동작을 다음처럼 만들 수도 있습니다.

```c
  // [!code --:1]
  printf("1: Learn C\tTo-do\n");
  // [!code ++:1]
  printf("%d: %s\t%s\n", 1, "Learn C", "To-do");
```

여기서 `%d`와 같은 것은 일종의 빈 자리를 나타내며, 뒤에 따라오는 값이 그 자리를 채웁니다.
`%d`에는 숫자가, `%s`에는 스트링이 온다는 뜻이며, 이들을 포맷<L>format</L> 지정자라고도 부릅니다.
이러한 것은 `printf()` 함수의 기능이며, 이름 뒤에 붙은 `f`가 포맷을 의미합니다.



# 할 일 보여주기

앞서 프로그램을 만드는 방법을 알아보았다면, 지금부터는 C 언어의 문법을 차례로 살펴볼 것입니다.

여기서의 작은 목표는 할 일을 보여주는 부분만 미리 만들어보는 것입니다.

```shellsession
$ ./todo
1: Learn C      To-do
2: Get a coffee Done
3: Take a walk  To-do
```

이것을 이용해 나중에 프로그램이 `list` 명령을 이해하도록 만들 것입니다.

## 이름 짓기 1: 상수

<Quote display={false}>
  매직 넘버<L>magic number</L>에 이름을 사용해라.

  <p slot="detail">Give names to magic numbers</p>

  <p slot="name">-- *The Practice of Programming* (1999)</p>
</Quote>

프로그래밍에서 이름 없이 둔 숫자를 매직 넘버<L>magic number</L>라고 부릅니다.
좋은 프로그래밍은 매직 넘버를 그대로 두지 않고 의미있는 이름을 붙여둡니다.

예를 들어, 앞서 작성한 다음 코드를 봅시다.

```c
  return 0;
```

사실 종료 코드 `0`은 정상적인 종료를 의미하는데, `stdlib.h` 헤더 파일에서는 이를 위한 이름을 제공합니다.

```c
#include <stdio.h>
// [!code ++:1]
#include <stdlib.h>

int main(void) {
  printf("%d: %s\t%s\n", 1, "Learn C", "To-do");

  // [!code --:1]
  return 0;
  // [!code ++:1]
  return EXIT_SUCCESS;
}
```

프로그래밍에서 이렇게 값이 고정된 것을 상수<L>constant</L>라고 부릅니다.
이제 `0`이 무엇인지 고민하는 대신, 그 의미를 바로 파악할 수 있습니다.

## 이름 짓기 2: 변수

이번엔 직접 이름을 지어봅시다.
다음과 같이 변수<L>variable</L>를 만들어 이름을 지어줄 수 있습니다.

```c
int main(void) {
  // [!code ++:3]
  int id = 1;
  char name[] = "Learn C";
  char status[] = "To-do";

  // [!code --:1]
  printf("%d: %s\t%s\n", 1, "Learn C", "To-do");
  // [!code ++:1]
  printf("%d: %s\t%s\n", id, name, status);
}
```

여기서 `id` 변수에 주목해봅시다.
`=` 기호는 오른쪽 값을 왼쪽에 대입하는데, 변수를 만들자마자 그 값을 정하므로 초기화<L>initialize</L>라고 부릅니다.

이렇게 만든 변수는 다음과 같이 언제든 바꿀 수 있습니다.
다만 이때에는 `int` 같은 키워드를 사용하지 않습니다.

```c
  id = 2;
```

한번 이렇게 `id`의 값을 바꿔서 결과를 확인해보세요.

## 메모리 빌리기: 변수와 타입

변수를 사용할 때 컴퓨터에서 무슨 일이 일어나는지 보겠습니다.

변수를 쓸 수 있는 이유는 어딘가에 그 값을 기억하고 있기 때문입니다.
그 공간은 메모리<L>memroy</L>라고 부르는 장치가 맡습니다.

<Figure src={fig1} alt="Memory">
  <FigureCaption slot="caption">그림 1. 컴퓨터 메모리의 구현인 랜덤 액세스 메모리 (RAM). -- 사진: [Harrison Broadbent][unsplash-hb]</FigureCaption>
</Figure>

[unsplash-hb]: https://unsplash.com/ko/%EC%82%AC%EC%A7%84/%EB%85%B9%EC%83%89-%ED%9A%8C%EB%A1%9C-%EA%B8%B0%ED%8C%90-%EA%B7%BC%EC%A0%91-%EC%B4%AC%EC%98%81-ING1Uf1Fc30

예를 들어, 방금의 코드를 봅시다.

```c
  int id = 1;
```

이것을 실행하면 컴퓨터의 장치인 메모리에서 공간을 일부 빌리고 그 안에 `1`을 기록합니다.
`int` 같은 키워드는 타입<L>type</L>이라고 부르며, 빌리는 크기를 정하게 됩니다.

<Figure src={fig2} alt="memory representation of int 1">
  <FigureCaption slot="caption">그림 2. `int` 타입으로 빌린 메모리에 기록된 `1`.</FigureCaption>
</Figure>

정확한 크기는 실행 환경마다 다르지만 직접 확인해볼 수 있습니다.
다음을 `int.c` 파일로 만들어봅시다.

```c
#include <stdio.h>

int main(void) {
  printf("int: %zu bytes\n", sizeof(int));

  return 0;
}
```

여기서 `sizeof` 연산자는 크기를 계산하고, `%zu` 포맷 지정자는 그 크기를 프린트합니다.
컴파일하고 실행하면 다음과 같습니다.

```shellsession
int: 4 bytes
```

여기서는 4 바이트라는 사실을 보여줍니다. (구체적인 결과는 다를 수 있습니다.)
그리고 1 바이트는 8 비트이므로, 32 비트가 됩니다.

따라서 앞서 만든 `id` 변수는 `1`이라는 값을 32비트로 기록한 것입니다.
자세한 설명은 생략하겠지만, 구체적으로는 다음과 같이 기록됩니다.

<Figure src={fig3} alt="bit representation of int 1">
  <FigureCaption slot="caption">그림 3. `int` 타입으로 빌린 메모리에 비트로 기록된 `1`.</FigureCaption>
</Figure>

한편 `char` 타입은 문자를 나타내는데, 이것은 정확히 1 바이트로 약속되어 있습니다.
(확인해보세요.)
그런데 앞서 스트링은 다음과 같이 초기화했습니다.

```c
  char name[] = "Learn C";
```

여기서 `[]`는 1 바이트 대신 그것을 여러 개 빌려옵니다.
이곳저곳에서가 아닌 한 덩어리로 빌려오는데, 이런 방식을 연속 메모리 할당<L>contiguous memory allocation</L>이라고 부릅니다.
즉 스트링의 각 문자는 1 바이트씩 기록됩니다.

<Figure src={fig4} alt="string in memory">
  <FigureCaption slot="caption">그림 4. `char` 배열 타입으로 빌린 메모리에 기록된 스트링.</FigureCaption>
</Figure>

그리고 `[]` 같은 타입을 배열<L>array</L>이라고 부릅니다.

위와 같이 만든 스트링은 그 길이를 미리 알 수 있으므로, 컴파일러는 필요한 메모리 크기를 계산해둡니다.
그래서 실행하면 필요한 만큼만 빌리게 됩니다.

## 코드 분리하기: 함수

<Quote display={false}>
  디테일한 구현은 숨겨라.

  <p slot="detail">Hide implementation details.</p>

  <p slot="name">-- *The Practice of Programming* (1999)</p>
</Quote>

앞서 `main()` 함수를 만들었듯이, 다른 함수도 만들어볼 수 있습니다.
프린트하는 부분을 별도의 함수로 분리해봅시다.

```c
#include <stdlib.h>

// [!code ++:3]
void print_task(int id, char name[], char status[]) {
  printf("%d: %s\t%s\n", id, name, status);
}
```

이렇게 함수를 만드는 일을 정의<L>define</L>한다고 부릅니다.

함수를 만드는 대표적인 이유는 호출하는 쪽에서 복잡한 디테일을 모르도록 만들기 위함입니다.
그러면 호출하는 쪽은 무엇을 하는지만 신경쓸 수 있으며, 어떻게 하는지는 알 필요가 없게 됩니다.

괄호 안의 변수는 파라미터<L>parameter</L>라고 부르며, 호출 시 인자로 넘어오는 값을 나타냅니다.
한편 여기서 `void` 타입은 돌려줄 값이 없다는 것을 의미하는데, 이것은 리턴 타입<L>return type</L>이라고 부릅니다.

이렇게 만든 함수를 `main()` 함수에서 사용해봅시다.

```c
  // [!code --:1]
  printf("%d: %s\t%s\n", id, name, status);
  // [!code ++:1]
  print_task(id, name, status);
```

실행하면 이전과 같을 것입니다. (한번 해보세요.)

## 함수 선언하기: 프로토타입

컴파일러는 위에서 아래로 소스 코드를 읽기 때문에, `print_task()` 함수를 먼저 읽고 `main()` 함수를 읽어야 합니다.
그렇지 않으면, 컴파일러는 `print_task()` 함수를 마주쳤을 때 무엇인지 모르기 때문입니다.

사람 또한 소스 코드를 위에서 아래로 읽습니다.
그런데 사람은 실행하는 순서대로 코드를 읽는 것이 편할 것입니다.
따라서 이런 순서라면 `main()` 함수가 먼저 위에 오는 것이 자연스럽습니다.

그렇다면 `print_task()` 함수를 어떻게 나중에 정의할 수 있을까요?
다음과 같이 함수가 존재한다고 미리 선언할 수 있습니다.

```c
// [!code --:3]
void print_task(int id, char name[], char status[]) {
  printf("%d: %s\t%s\n", id, name, status);
}
// [!code ++:1]
void print_task(int id, char name[], char status[]);
```

이것을 함수의 프로토타입<L>prototype</L>이라고 부릅니다.

이제 `main()` 함수 다음으로 `print_task()` 함수를 옮길 수 있습니다.

```c
int main(void) {
  int id = 1;
  char name[] = "Learn C";
  char status[] = "To-do";

  print_task(id, name, status);

  return EXIT_SUCCESS;
}

// [!code ++:3]
void print_task(int id, char name[], char status[]) {
  printf("%d: %s\t%s\n", id, name, status);
}
```

프로토타입은 함수의 정의와 일치해야 한다는 점을 참고하세요.
나중에 함수를 수정해야 한다면, 프로토타입도 신경써서 고쳐야 합니다.

## 연관있는 변수 모으기: 구조체

다음 세 변수는 하나의 할일을 구성합니다.

```c
  int id = 1;
  char name[] = "Learn C";
  char status[] = "To-do";
```

이것을 하나의 의미로 모을 수 있을까요?

C 언어에서는 연관있는 변수를 모아 새로운 타입을 만들 수 있습니다.

```c
#include <stdlib.h>

// [!code ++:5]
struct task {
  int id;
  char* name;
  char* status;
};
```

이것은 구조체<L>structure</L>라고 부르며, `id`와 같은 것은 구조체의 필드<L>field</L>라고 부릅니다.
여기서 `char *` 타입은 나중에 자세히 설명하겠지만, 지금은 스트링을 나타내는 타입이라고 이해하고 넘어가겠습니다.

이렇게 만든 구조체는 새로운 타입이며, 다음과 같이 초기화할 수 있습니다.

```c
  struct task first = {
    .id = 1,
    .name = "Learn C",
    .status = "To-do",
  };
```

그리고 다음과 같이 점을 이용해 필드에 접근합니다.

```c
  printf("%d: %s\t%s\n", first.id, first.name, first.status);
```

이에 따라 `print_task()` 함수를 고쳐봅시다.

```c
// [!code --:1]
void print_task(int id, char name[], char status[]);
// [!code ++:1]
void print_task(struct task t);
```

함수 호출 또한 수정합니다.

```c
  // [!code --:1]
  print_task(id, name, status);
  // [!code ++:1]
  print_task(first);
```

앞서 소개한 내용을 이용해 다음 작업을 직접 해보시기 바랍니다.

- `main()` 함수에서 `id`를 비롯한 기존 변수를 구조체 변수로 대체.
- `print_task()` 함수의 구현을 수정.

수정한 결과는 잠시후에 공개할 것입니다.

## 타입 별명 짓기: `typedef`

앞서 타입에 매번 `struct` 키워드를 붙이는 것은 귀찮을 수도 있습니다.
줄인 이름을 만들어봅시다.

```c
// [!code ++:1]
typedef struct task task;
struct task {
  int id;
  char* name;
  char* status;
};
```

이것은 `struct task` 타입에 간단히 `task`라는 이름을 주겠다는 것입니다.

또는 이렇게도 쓸 수 있습니다.

```c
typedef struct task {
  int id;
  char* name;
  char* status;
} task;
```

이것은 구조체를 선언함과 동시에 별명을 지어줍니다.
여기서는 이 방법을 쓰겠습니다.

이렇게 만든 별명은 기존과 같이 타입처럼 그대로 쓸 수 있습니다.
함수의 프로토타입을 고쳐봅시다.

```c
// [!code --:1]
void print_task(struct task t);
// [!code ++:1]
void print_task(task t);
```

이와 같이 나머지 부분도 수정해보시기 바랍니다.

## 같은 타입의 나열: 배열

여태까지는 할 일이 하나만 있었지만, 조금 심심하니 두 번째를 추가해봅시다.

```c
  task first = {
    .id = 1,
    .name = "Learn C",
    .status = "To-do",
  };
  // [!code ++:5]
  task second = {
    .id = 2,
    .name = "Get a coffee",
    .status = "Done",
  };
```

그런데 이런 식으로 별개의 변수로 만드는 대신, 배열을 이용할 수도 있습니다.
구조체가 타입이 다른 것들의 모임이라면, 배열은 타입이 같은 것들의 모임입니다.

앞서 만든 두 개의 할일은 다음과 같이 배열로 만들 수 있습니다.

```c
  task tasks[] = {
    {
      .id = 1,
      .name = "Learn C",
      .status = "To-do",
    }, {
      .id = 2,
      .name = "Get a coffee",
      .status = "Done",
    }
  };
```

여기에 세 번째를 직접 추가해보시기 바랍니다.

배열 안에 있는 각각의 값은 원소<L>element</L>라고 부르며, 다음과 같이 접근할 수 있습니다.

```c
  // [!code --:1]
  print_task(first);
  // [!code ++:1]
  print_task(tasks[0]);
```

여기서 `[0]`은 배열의 첫 번째 원소를 가져오는데, `0`과 같은 순번을 인덱스<L>index</L>라고 부릅니다.

C 언어에서 인덱스는 `0`부터 시작하기 때문에 `0`은 첫 번째 원소를 가리킵니다.
처음에는 혼동스러울 수도 있지만, 첫 번째 원소로부터 떨어진 거리라고 이해해보시기 바랍니다.
사실 대부분의 프로그래밍 언어가 이 관습을 따릅니다.

한번 인덱스를 바꿔서 결과를 확인해보면 어떨까요?

```c
  // [!code --:1]
  print_task(tasks[0]);
  // [!code ++:1]
  print_task(tasks[1]);
```

실행 결과는 다음과 같습니다.

```shellsession
2: Get a coffee Done
```

배열의 원소가 세 개일 때, `2`보다 큰 인덱스는 의미상 말이 되지 않습니다.
하지만 C 언어는 그런 인덱스로 접근하는 것을 막지 않습니다.

```c
  print_task(tasks[3]);
```

어떤 값이 나오는지 한번 실행해보세요.

원소가 `n` 개일 때 인덱스 `n`으로 접근하는 일은 종종 나타나는 실수이기도 합니다.
그래서 오프 바이 원<L>off-by-one</L>이라는 이름도 있습니다.
하지만 이런 코드는 절대 작성하면 안 되므로, 여기서만 시험해보고 다른 곳에서는 쓰지 마세요.

## 원소마다 반복하기: `for` 반복문

이제 모든 할 일을 보여주는 일만 남았습니다.
가장 간단한 방법은 다음과 같이 일일이 출력하는 것입니다.

```c
  print_task(tasks[0]);
  print_task(tasks[1]);
  print_task(tasks[2]);
```

그러면 결과는 다음과 같습니다.

```shellsession
1: Learn C      To-do
2: Get a coffee Done
3: Take a walk  To-do
```

이렇게 해도 동작하지만, 손수 반복하는 대신 반복문에게 맡겨봅시다.

```c
  for (size_t i = 0; i < 3; i++) {
    print_task(tasks[i]);
  }
```

이것은 변수 `i`를 초기화하고, `i`가 `3` 미만인 동안 반복하며, 반복마다 `i++`로 `i`를 하나씩 증가시킵니다.

잠깐 `i++`를 설명하자면, 다음과 같은 대입을 줄인 표현입니다.

```c
  i = i + 1;
```

이것은 다음과 같은 문법으로도 줄일 수 있습니다.

```c
  i += 1;
```

그리고 `i++`는 하나씩 더하는 이 경우를 더 줄인 것입니다. (`i--`도 마찬가지입니다.)

한편 `3`이라는 매직 넘버 대신, 원소의 개수라는 의미를 드러내봅시다.
원소의 개수는 다음과 같이 구할 수 있습니다.

```c
  size_t size = (sizeof tasks) / (sizeof tasks[0]);
```

`tasks` 배열은 원소가 세 개라면 `task` 타입의 세 배만큼 메모리를 빌렸을 것입니다.
따라서 `task` 타입의 크기가 얼마인지 상관 없이, `size` 변수는 항상 원소의 개수를 갖게 됩니다.

이를 이용해 반복문을 다음과 같이 고쳐봅시다.

```c
  // [!code --:1]
  for (size_t i = 0; i < 3; i++) {
  // [!code ++:1]
  for (size_t i = 0; i < size; i++) {
```

실행 결과는 이전과 같을 것입니다.

## 중간 정리: 소스 코드

여태까지 작성한 코드는 전체적으로 다음과 같습니다.

```c
typedef struct task {
  int id;
  char* name;
  char* status;
} task;

void print_task(task t);

int main(void) {
  task tasks[] = {
    {
      .id = 1,
      .name = "Learn C",
      .status = "To-do",
    }, {
      .id = 2,
      .name = "Get a coffee",
      .status = "Done",
    }, {
      .id = 3,
      .name = "Take a walk",
      .status = "To-do",
    }
  };

  size_t size = (sizeof tasks) / (sizeof tasks[0]);
  for (size_t i = 0; i < size; i++) {
    print_task(tasks[i]);
  }

  return EXIT_SUCCESS;
}

void print_task(task t) {
  printf("%d: %s\t%s\n", t.id, t.name, t.status);
}
```

앞서 직접 수정했던 부분과 비교해보시기 바랍니다.



# 코드 정리하기

지금까지 기본적인 문법으로 프로그램을 만들어봤습니다.
그런데 소스 코드에는 다음 스트링과 같이 이름 없는 값이 남아있기도 합니다.

```c
      .status = "To-do",
```

또한 다음 반복문은 별도의 함수로 분리해볼 여지가 있습니다.

```c
  for (size_t i = 0; i < 3; i++) {
    print_task(tasks[i]);
  }
```

여기서는 새로운 기능을 추가하지 않고, 내부적으로 코드를 정리해보겠습니다.
그리고 를 통해 C 언어의 부가적인 기능을 알아봅니다.

## 함수 분리: 배열 파라미터

할 일을 모두 보여주는 것 또한 하나의 작업이므로, 반복문을 함수로 분리해봅시다.
이 함수는 배열과 원소의 개수를 받습니다.

```c
void print_tasks(task tasks[], size_t size) {
  for (size_t i = 0; i < size; i++) {
    print_task(tasks[i]);
  }
}
```

그리고 `main`에서 다음과 같이 사용합니다.

```c
  // [!code --:3]
  for (size_t i = 0; i < size; i++) {
    print_task(tasks[i]);
  }
  // [!code ++:1]
  print_tasks(tasks, size);
```

이 함수의 프로토타입은 다음과 같습니다.
적당한 위치에 추가해보세요.

```c
void print_tasks(task tasks[], size_t size);
```

그런데 왜 이 함수는 왜 `size` 파라미터를 받을까요?
즉 원소의 개수를 왜 알아야 할까요?
다음과 같이 함수 안에서 구할 수는 없을까요?

```c
void print_tasks(task tasks[]) {
  // [!code warning:1]
  size_t size = (sizeof tasks) / (sizeof tasks[0]);
  for (size_t i = 0; i < size; i++) {
    print_task(tasks[i]);
  }
}
```

사실 함수의 파라미터로 넘어온 배열은 그 크기에 대한 정보를 잃습니다.
따라서 크기를 따로 알려줄 필요가 있습니다.
이에 대한 자세한 내용은 나중에 알아보겠습니다.

## 상태 표현하기 1: 전역 변수

`status` 필드의 값을 주목해봅시다.
여기서는 스트링으로 상태를 직접 나타내고 있는데, 똑같은 스트링을 반복해서 써야하므로 중복처럼 보이기도 합니다.

```c
      .id = 1,
      .name = "Learn C",
      .status = "To-do",
```

따라서 스트링 대신 숫자로 상태를 나타내봅시다.
이를 위해 상태 값을 함수 바깥에서 정의합니다.

```c
int to_do = 0;
int done = 1;
```

이런 변수는 모든 함수에서 쓸 수 있기 때문에 전역 변수 또는 글로벌<L>global</L> 변수라고 부릅니다.
이와 반대로, 다음과 같이 함수 안에서 만든 변수는 지역 변수 또는 로컬<L>local</L> 변수라고 부르며, 다른 함수에서 쓸 수 없습니다.

```c
void foo(void) {
  int bar = 42;
}
```

위 예시에서 `bar` 변수는 마치 `{ }` 블록 안에서만 보이는 것처럼 생각할 수 있습니다.
따라서 이 변수는 블록 스코프<L>block scope</L>를 가진다고 부릅니다.
이처럼 전역 변수는 전역 스코프를 가진다고 말합니다.

전역 변수는 모든 곳에서 값을 바꿀 수 있기 때문에 그 값을 예상하기가 쉽지 않습니다.
이것은 코드의 이해를 쉽게 방해하기 때문에, 가급적이면 사용을 피해야 합니다.
따라서 지금처럼 전역 변수가 필요하다면, 나중에 값을 바꿀 수 없도록 만드는 것이 좋습니다.

```c
// [!code --:2]
int to_do = 0;
// [!code ++:2]
const int to_do = 0;
```

`const` 키워드로 선언한 변수는 값을 바꾸려고 하면 컴파일되지 않습니다. (한번 해보세요.)

```c
// [!code error:1]
todo = 42;
```

이와 같이 나머지 변수도 바꿔보시기 바랍니다.

이제 `status` 필드를 숫자 타입으로 고쳐봅시다.

```c
typedef struct task {
  int id;
  char* name;
  // [!code --:1]
  char* status;
  // [!code ++:1]
  int status;
} task;
```

이에 따라 실제 값도 고칩니다.
예를 들어, 첫 번째 할 일은 다음과 같이 `0`으로 수정합니다.

```c
      .id = 1,
      .name = "Learn C",
      // [!code --:1]
      .status = "To-do",
      // [!code ++:1]
      .status = 0,
```

나머지도 이와 같이 수정해보시기 바랍니다.

이어서 포맷 지정자도 수정할 필요가 있습니다.

```c
  // [!code --:1]
  printf("%d: %s\t%s\n", t.id, t.name, t.status);
  // [!code ++:1]
  printf("%d: %s\t%d\n", t.id, t.name, t.status);
```

실행 결과는 다음과 같습니다.

```shellsession
1: Learn C      0
2: Get a coffee 1
3: Take a walk  0
```

코드의 중복은 줄었지만, 실행 결과가 조금 읽기 어려워졌네요.
이 문제를 바로 해결해봅시다.

## 배열을 함수처럼 쓰기: 전역 배열 변수

앞서 할 일의 상태를 숫자로 바꿨지만, 프린트할 때는 스트링으로 보여주고 싶습니다.
즉 다음과 같은 결과를 원합니다.

```shellsession
1: Learn C      To-do
2: Get a coffee Done
3: Take a walk  To-do
```

이러한 스트링은 전역 변수 배열로 미리 정해놓을 수 있습니다.

```c
char* const status_names[] = { "To-do", "Done" };
```

여기서 배열의 인덱스가 앞서 만든 전역 변수와 대응됩니다.
따라서 다음과 같이 사용할 수 있습니다.

```c
printf("%s\n", status_names[to_do]);
printf("%s\n", status_names[done]);
```

그러면 결과는 다음과 같을 것입니다.

```shellsession
To-do
Done
```

이 배열은 마치 숫자를 받아 스트링을 리턴하는 함수로 생각할 수 있습니다.

이런 원리로 상태를 스트링으로 프린트하도록 고칩니다.

```c
void print_task(task t) {
  // [!code ++:1]
  char* status = status_names[t.status];

  // [!code --:1]
  printf("%d: %s\t%d\n", t.id, t.name, t.status);
  // [!code ++:1]
  printf("%d: %s\t%s\n", t.id, t.name, status);
}
```

실행하면 목표한 결과가 나오는지 확인해보세요.

이와 같이 내부적인 값과 사용자에게 보여주는 표현을 분리하는 것은 프로그래밍에서 자주 나타나는 패턴입니다.

## 상태 표현하기 2: `enum`

상태를 여러 개의 변수로 두는 대신, 다음과 같이 묶을 수도 있습니다.

```c
// [!code --:2]
const int to_do = 0;
const int done = 1;
// [!code ++:1]
enum status { to_do, done };
```

이렇게 수정해도 같은 결과가 나타납니다. (한번 해보세요.)

`enum` 타입은 열거형, 또는 이뉴머레이션<L>enumeration</L>이라고 부르고, 값을 나열하는데 사용합니다.
나열한 이름에는 값이 `0`부터 할당되기 때문에, 이전 코드와 동일하게 됩니다.
즉 다음은 같은 내용입니다.

```c
enum status { to_do = 0, done = 1 };
```

이어서 배열과의 연관성을 다음과 같이 표현합시다.

```c
// [!code --:1]
char* status_names[] = { "To-do", "Done" };
// [!code ++:4]
char* status_names[] = {
  [to_do] = "To-do",
  [done] = "Done"
};
```

이 문법은 각 인덱스에 어떤 값이 들어갈지 명시적으로 정합니다.
이것은 다음과 같습니다.

```c
char* status_names[] = {
  [0] = "To-do",
  [1] = "Done"
};
```

이렇게 배열을 수정해도 바뀐 내용은 사실상 없습니다.
하지만 나중에 상태 값을 추가할 때, 배열도 바꿔야할 필요가 사라지게 됩니다.

예를 들어, 진행 중이라는 상태를 추가한다고 해봅시다.

```c
// [!code --:1]
enum status { to_do, done };
// [!code ++:1]
enum status { to_do, doing, done };
```

그러면 `done`의 값은 자동으로 `2`가 되므로, 배열은 다음과 같게 됩니다.

```c
char* status_names[] = {
  [0] = "To-do",
  [2] = "Done"
};
```

여기서 다음과 같은 코드는 고치지 않아도 여전히 잘 동작합니다.

```c
status_names[done];
```

코드의 수정이 쉽다는 것 외에도, 이와 같이 의미적으로 결합하는 것은 코드를 읽을 때 이해를 도울 것입니다.



# 타입과 포인터

여기서는 말 없이 넘어왔던 타입에 대해 설명하겠습니다.
그중에 포인터<L>pointer</L>는 C 언어의 진입 장벽을 높이는 요소로 알려져 있지만, 메모리와 연관지어 생각해보면 어렵지 않게 이해할 수 있습니다.
포인터를 쓰는 이유를 알아보고, 마지막에는 포인터를 이용해 코드를 개선해보겠습니다.

## 정수 타입과 부호

`int` 타입은 정확히는 정수<L>integer</L> 타입으로, 소수점 없는 숫자만 표현할 수 있습니다.
C 언어는 정수 타입에 두 가지 종류를 제공하는데, 부호가 있는 것과 없는 것입니다.

```c
unsigned int foo = 42;
signed int bar = -99;
```

너무 길다면 `int`를 생략할 수 있습니다.

```c
unsigned foo = 42;
signed bar = -99;
```

이렇게 바꾼 타입은 메모리 크기를 바꾸지는 않지만, 나타낼 수 있는 숫자의 범위를 다르게 만듭니다.

간단한 프로그램으로 범위를 확인해볼 수 있습니다.
다음을 `ints.c` 파일로 만들어봅시다.

```c
int main(void) {
  printf("signed int  : min = %11d, max = %d\n", INT_MIN, INT_MAX);
  printf("unsigned int: min = %11u, max = %u\n", 0, UINT_MAX);
}
```

여기서 사용한 상수는 `limits.h` 헤더가 제공합니다.
`%u`는 부호 없는 수를 프린트하며, `%11d`는 최소 11글자만큼 차지하되 문자열을 오른쪽으로 정렬해줍니다.

```shellsession
signed int  : min = -2147483648, max = 2147483647
unsigned int: min =           0, max = 4294967295
```

이 결과가 말해주는 것은 무엇일까요?

앞서 `int` 타입이 32 비트라는 사실을 봤습니다.
그런데 각 비트는 두 가지의 경우를 나타낼 수 있기 때문에, 32 비트는 총 $2^{32}$ 가지의 값을 나타낼 수 있습니다.
이것은 정확히 $0$부터 $4\,294\,967\,295$까지의 정수 개수이기도 합니다.
(`signed` 타입도 마찬가지입니다. 한번 개수를 세보세요.)

## 크기가 다른 정수 타입

만약 `int` 타입으로 충분하지 않다면, 더 큰 메모리를 빌릴 수도 있습니다.

```c
  long n1 = 42;
  long long n2 = 99;
  printf("n1 = %ld, n2 = %lld\n", n1, n2);
```

이러한 타입은 `int` 타입보다 더 넓은 범위의 숫자를 나타낼 수 있습니다.
여기에는 `%ld`, `%lld` 같은 포맷 지정자를 쓴다는 사실을 참고하세요.

반면 더 작은 크기도 있습니다.

```c
  short n3 = 42;
  char n4 = 99;
```

앞서 `char` 타입은 문자를 나타낸다고 했지만, 사실 1 바이트를 차지하는 정수 타입이기도 합니다.
이것을 문자로 해석할 수 있는 이유는, 각 숫자를 어떤 문자로 대응시킬지 미리 약속했기 때문입니다.

실제로 다음과 같이 확인할 수 있습니다.

```c
  char c = 'A';
  printf("char: %%d = %d, %%c = %c\n", c, c);
```

여기서 `%%`는 퍼센트 문자를 하나 프린트하고, `%c`는 문자로서 프린트합니다.
실행하면 다음과 같습니다.

```shellsession
char: %d = 65, %c = A
```

즉 변수에는 사실 정수인 `65`가 들어있고, 이것을 문자로 프린트할 때 `A`가 되는 것입니다.

한편, 별다른 설명없이 넘어갔던 `size_t` 타입은 부호 없는 정수 타입으로서 크기를 나타낼 때 사용합니다.
이 타입은 이론적으로 가능한 최대 메모리 크기까지 표현할 수 있기 때문에, 배열의 인덱스나 반복문의 변수에 주로 사용됩니다.

이 타입의 크기는 실행 환경마다 다르게 정의되어 있기 때문에, 다음과 같이 별도의 포맷 지정자를 사용합니다.
`sizeof` 연산자의 결과는 `size_t` 타입을 갖는다는 사실을 참고하세요.

```c
  printf("size_t: %zu bytes\n", sizeof(size_t));
```

여기서의 결과는 다음과 같습니다.

```shellsession
size_t: 8 bytes
```

이 실행 환경에서 메모리 주소는 64 비트로 표현되기 때문에, `size_t` 타입 또한 64 비트의 크기를 갖습니다.

## 포인터 타입: 주소 값 다루기

앞서 다음과 같은 코드를 사용했습니다.

```c
  char* name = "Learn C";
```

이처럼 타입에 `*`을 붙인 것을 포인터<L>pointer</L> 타입이라고 하며, 메모리 주소를 값으로 가집니다.

그런데 스트링은 왜 이런 타입을 가지는 것일까요?
이것을 설명하려면, 먼저 포인터 타입 자체를 설명할 필요가 있습니다.

따라서 포인터를 직접 사용해보겠습니다.
다음을 `pointer.c` 파일로 만듭니다.

```c
int main(void) {
  int num = 42;
  int* p = &num;
}
```

`&` 연산자는 변수의 주소를 가져오기 때문에, 포인터 `p`는 `num` 변수의 주소를 갖습니다.
이처럼 포인터는 다른 변수의 주소를 가리키기 위해 주로 사용됩니다.
그래서 포인터라는 이름을 가집니다.

이것을 메모리 입장에서 보겠습니다.
메모리에는 값의 위치를 나타내기 위해 각 바이트마다 순번을 매겨놓는데, 이것을 메모리 주소<L>memory address</L>라고 부릅니다.

<Figure src={fig5} alt="string in memory">
  <FigureCaption slot="caption">그림 5. 포인터 다이어그램. `p` 변수는 `num` 변수의 주소를 가집니다.</FigureCaption>
</Figure>

`num` 변수를 초기화하면, 그 값은 메모리 어딘가에 기록됩니다.
그 주소를 편의상 `100` 번이라고 한다면, `p` 변수는 `100` 번으로 초기화되는 것입니다.


이렇게 만든 포인터는 마치 원래의 변수처럼 사용할 수 있습니다.
이때 `*` 연산자를 이용합니다.

```c
  printf("%d\n", *p);
```

실행해보면 다음과 같습니다.

```shellsession
42
```

여기서 `*` 연산자는 타입을 지정할 때 사용한 `*` 문자와는 다릅니다.
즉 `int*`는 포인터 타입을 지정하기 위한 문법이고, `*` 연산자는 가리키는 변수의 값을 가져오라는 명령입니다.
이것은 역참조, 또는 디레퍼런스<L>dereference</L>라고 부릅니다.
(개인적으로는 처음 볼 때 혼동스러운 용어라고 생각하기 때문에, 여기서는 그냥 접근한다고 표현하겠습니다.)

## 포인터 사용 예시: 스왑 함수

그렇다면 포인터는 어떤 경우에 쓰는 것일까요?
포인터가 필요한 대표적인 상황은 함수의 파라미터를 직접 바꿔야하는 경우입니다.

두 변수의 값을 바꿔야 하는 경우를 예로 들어봅시다.

```c
int main(void) {
  int n = 42;
  int m = 99;
}
```

이것을 `swap.c` 파일로 준비하고, `n`과 `m`의 값을 서로 바꾸는 문제를 해결해보시기 바랍니다. (한번 해보세요.)

이 문제는 다음과 같이 풀 수 있습니다.

```c
  int temp = n;
  n = m;
  m = temp;
  printf("Swapped directly: %d, %d\n", n, m);
```

그렇다면 이 코드를 그대로 함수로 분리할 수 있을까요?
시도해보면 불가능하다는 것을 알게 됩니다.

예를 들어, 다음과 같이 만들었다고 해봅시다.

```c
void bad_swap(int x, int y) {
  int temp = x;
  x = y;
  y = temp;
}
```

이 함수는 호출해도 두 값이 바뀌지 않습니다.

```c
  bad_swap(n, m);
```

왜 일까요?
인자로 넘긴 값은 복사되어 전달되기 때문입니다.
즉 `n`의 값은 `x`로 전해지지만, 서로 다른 메모리 공간을 차지합니다.

<Figure src={fig6} alt="memory diagram of an argument">
  <FigureCaption slot="caption">그림 6. 인자로 전달된 값의 메모리 다이어그램. 변수 `n`과 `x`는 다른 메모리 공간을 차지하므로, `x`를 바꿔도 `n`이 바뀌지 않습니다.</FigureCaption>
</Figure>

따라서 `bad_swap()` 함수에서 값을 바꾸더라도, 변수 `n`과 `m`은 영향을 받지 않는 것입니다.

정말일까요?
변수 `n`의 주소는 다음과 같이 프린트할 수 있습니다.

```c
  printf("n: %p\n", &n);
```

변수 `x`도 이와 같이 프린트해서 결과를 확인해보세요.
그러면 다음과 비슷하게 나타납니다. (구체적인 값은 다를 수 있습니다.)

```shellsession
x: 0xfffff408a1ec
n: 0xfffff408a204
```

이렇게 값을 복사해 전달하는 방식을 값에 의한 호출<L>call-by-value</L>, 또는 값에 의한 전달<L>pass-by-value</L>라고 부릅니다.
C 언어는 항상 이 방식으로 인자를 함수에 전달합니다.

이 문제의 정답은 다음과 같습니다.

```c
void swap(int* x, int* y) {
  int temp = *x;
  *x = *y;
  *y = temp;
}
```

이처럼 값을 전달하는 대신, 변수의 주소를 전달합니다.
그러면 인자로 넘어온 `n`의 값을 직접 바꿀 수 있습니다.

<Figure src={fig7} alt="memory diagram of a pointer argument">
  <FigureCaption slot="caption">그림 7. 인자로 전달된 포인터의 메모리 다이어그램. 변수 `x`는 변수 `n`의 주소를 가지므로, `x`를 통해 `n`의 값을 바꿀 수 있습니다.</FigureCaption>
</Figure>

호출하면 두 변수의 값이 바뀝니다.

```c
  swap(&n, &m);
```

포인터는 이와 같이 전달한 인자의 값을 직접 바꿀 필요가 있을 때 사용합니다.

## 포인터 초기화와 널 포인터

<Quote display={false}>
  C 언어가 유지하는 기본 철학은 프로그래머가 자신이 무엇을 하는지 안다는 것이다.

  <p slot="detail">C retains the basic philosophy that programmers know what they are doing.</p>

  <p slot="name">-- *The C Programming Language* (1988)</p>
</Quote>

C 언어는 다음과 같이 주소를 직접 지정하는 일을 막지 않습니다.

```c
  // [!code warning:1]
  int* p = 42;
```

하드웨어를 저수준으로 다뤄야 할 임베디드 환경 같은 상황이 아니라면, 이러한 포인터의 사용은 정상적인 동작이 나타나지 않으므로 피해야 합니다.

포인터의 구체적인 값은 특별한 상황이 아니라면 신경쓰지 말아야 합니다.
앞서 포인터가 가진 주소 값을 다음과 같이 프린트했습니다.

```c
  printf("n: %p\n", &n);
```

실행 결과는 보통 매번 달라질 수 있습니다.
왜냐면 매번 다른 메모리 공간을 빌릴 수 있기 때문입니다.
또한 대부분의 운영 체제는 가상 메모리를 활용하기 때문에, 이 메모리 주소는 '진짜'가 아닌 가상의 주소라는 점을 참고하세요.

하지만 다음과 같이 구체적인 값을 쓰는 경우가 있습니다.

```c
  int* p = 0;
```

이처럼 `0`으로 초기화한 포인터는 널 포인터<L>null pointer</L>라고 부르며, 유효하지 않은 상태를 의미합니다.

포인터는 널 포인터나 다른 변수의 주소로 반드시 초기화하는 것이 좋습니다.
특히, C 언어는 변수를 초기화하지 않은 채로 두는 것을 허용하는데, 포인터의 경우 치명적입니다.

```c
  // [!code warning:1]
  int* p;
```

이것은 변수를 선언<L>declare</L>한다고 부르며, 어떤 값이 들어있는지 모릅니다.
따라서 그런 주소에 접근하는 것은 정상적인 동작이 나타나지 않습니다.

## 문자 포인터: 스트링

이제 설명을 미뤘던 `char*` 타입을 설명할 차례입니다.

```c
  char* name = "Learn C";
```

이것은 `name`이 첫 번째 문자를 가리키도록 만듭니다.
실제로 다음을 `string.c` 파일로 만들어 확인해봅시다.

```c
int main(void) {
  char* name = "Learn C";
  printf("%c\n", *name);
}
```

실행하면 첫 글자가 나타납니다.

```shellsession
L
```

그런데 어떻게 이것이 전체 스트링을 나타낼 수 있을까요?

사실 C 언어에서 스트링이란, 마지막 원소의 값이 `0`인 문자 배열과 같습니다.
즉 `name` 변수는 다음과 같습니다.

```c
  char array[] = { 'L', 'e', 'a', 'r', 'n', ' ', 'C', 0 };
```

여기서 작은따옴표 문자 `'`로 감싼 것을 문자 또는 캐릭터<L>character</L>라고 부릅니다.
즉 스트링은 문자의 배열입니다.

마지막 `0`은 문자라는 의미를 살리기 위해, 다음과 같이 쓸 수도 있습니다.

```c
  char array[] = { 'L', 'e', 'a', 'r', 'n', ' ', 'C', '\0' };
```

`'\0'`은 널 문자<L>null character</L>라고도 부릅니다.
스트링은 항상 널 문자로 끝나기 때문에, 첫 번째 문자만 가리키더라도 문자열 전체를 알 수 있게 됩니다.

실제로 그런지 다음과 같이 프린트해보세요.

```c
  printf("%s\n", array);
```

`array` 자리에 포인터 변수 `name`이 오더라도 결과가 같은지 확인해보세요.

## 배열 디케이

그런데 방금 `array` 변수는 배열이었습니다.
그렇다면 포인터 자리에 배열이 와도 되는 것일까요?

결론부터 말하자면 그렇습니다.
사실 배열 변수를 그대로 쓰면 첫 번째 원소를 가리키는 포인터 변수가 됩니다.
즉 다음을 실행한 것과 같습니다.

```c
  printf("%s\n", &array[0]);
```

결과가 같은지 확인해보세요.

이렇게 배열이 포인터로 바뀌는 것을 암묵적 변환<L>implicit conversion</L>, 또는 디케이<L>decay</L>라고 부릅니다.
이것은 앞에서 배열 파라미터가 크기 정보를 잃어버렸던 이유이기도 합니다.

```c
void print_tasks(task tasks[], size_t size);
```

위 프로토타입은 사실 다음과 같습니다.

```c
void print_tasks(task* tasks, size_t size);
```

이 함수에서 인덱스로 접근했던 코드는 포인터의 연산이기도 합니다.

```c
    print_task(tasks[i]);
```

이것은 다음을 줄여쓴 표현입니다.

```c
    print_task(*(tasks + i));
```

포인터의 덧셈은 `i`를 더하라는 것이 아니라, 다음 `i` 번째 원소의 주소를 구하라는 뜻입니다.
따라서 `*` 연산자를 통해 `i` 번째 원소의 값을 가져오게 됩니다.

## 메모리 사용 줄이기: 포인터 파라미터

앞서 인자는 복사되어 전달된다고 언급했습니다.
다음 함수도 예외는 아닙니다.

```c
void print_task(task t);
```

따라서 호출 시 모든 필드를 복사합니다.

그런데 그럴 필요가 있을까요?
포인터를 이용하면 이런 복사로 인한 메모리 낭비를 피할 수 있습니다.
구조체 전체 대신 그 주소를 넘겨보도록 바꿔봅시다.

```c
void print_task(task* t) {
  char* status = status_names[t->status];
  
  printf("%d: %s\t%s\n", t->id, t->name, status);
}
```

여기서 `t->id`는 다음을 줄여쓴 것과 같습니다.

```c
  (*t).id;
```

즉 포인터가 가리키는 구조체의 필드에 접근합니다.

이에 따라 `print_tasks()` 함수도 고칩니다.

```c
void print_tasks(task tasks[], size_t size) {
  for (size_t i = 0; i < size; i++) {
    // [!code --:1]
    print_task(tasks[i]);
    // [!code ++:1]
    print_task(tasks + i);
  }
}
```

이렇게 수정한 결과는 이전과 실행 결과가 같습니다. (한번 해보세요.)



# 커맨드라인 인자 처리하기

처음에 목표했던 것은 다음과 같이 실행할 수 있도록 만드는 것이었습니다.

```shellsession
$ ./todo list
```

여기서 `list` 같이 부가적으로 넘기는 스트링을 커맨드라인 인자<L>command-line arguments</L>라고 부릅니다.
여기서는 프로그램이 이것을 이해하도록 만들 것입니다.

## 커맨드라인 인자 읽기: `if` 조건문

C 언어에서는 커맨드라인 인자를 다음과 같이 받습니다.

```c
int main(int argc, char* argv[]) {
  return 0;
}
```

이것은 `main()` 함수의 두 번째 정의입니다.

실제로 커맨드라인 인자를 확인하는 프로그램을 `args.c` 파일로 만들어봅시다.

```c
int main(int argc, char* argv[]) {
  for (int i = 0; i < argc; i++) {
    printf("argv[%d]: %s\n", i, argv[i]);
  }
  printf("argv[%d]: %p\n", argc, argv[argc]);

  return 0;
}
```

여기서 `argc` 값은 커맨드라인 인자의 개수를, `argv` 배열에는 그 인자가 스트링으로 들어있습니다.
실행하면 다음과 같습니다.

```shellsession
$ ./todo list
argv[0]: ./todo
argv[1]: list
argv[2]: (nil)
```

이처럼 첫 번째 원소에는 프로그램 이름이 있고, 마지막에는 널 포인터가 들어있습니다.

이를 이용해 `list`를 커맨드라인 인자로 받았을 때 할 일을 출력하도록 수정해봅시다.

```c
  // [!code --:4]
  size_t size = (sizeof tasks) / (sizeof tasks[0]);
  print_tasks(tasks, size);
  
  return EXIT_SUCCESS;
  // [!code ++:6]
  if (strcmp(argv[1], "list") == 0) {
    size_t size = (sizeof tasks) / (sizeof tasks[0]);
    print_tasks(tasks, size);
    
    return EXIT_SUCCESS;
  }
```

여기서 `if` 키워드를 사용한 부분은 조건문이라고 부르고, 괄호 안의 조건이 참일 때만 실행합니다.

스트링 비교를 위해 사용한 `strcmp()` 함수는 `string.h` 헤더에 들어있습니다.
(직접 `#include` 줄을 추가해보세요.)
컴파일하고 실행하면 다음과 같이 동작합니다.

```shellsession
$ ./todo list
1: Learn C      To-do
2: Get a coffee Done
3: Take a walk  To-do
```

## 스트링 비교: `strcmp()` 함수

스트링을 다음과 같이 비교하지 않은 이유는 무엇일까요?

```c
  // [!code warning:1]
  if (argv[1] == "list") {
```

스트링은 포인터 타입이라는 점을 떠올려본다면, 이것은 문자 비교가 아닌 주소 값 비교라는 것을 알 수 있습니다.

이것은 의도한 동작이 아니며, 사실은 잘못된 코드입니다.
다음과 같이 자세한 경고를 보여주도록 컴파일하면 메시지가 나타납니다.

```shellsession
$ gcc -Wall todo.c
todo.c: In function 'main':
todo.c:37:15: warning: comparison with string literal results in unspecified behavior [-Waddress]
   37 |   if (argv[1] == "list") {
      |               ^~
```

컴파일 시 `-Wall` 같은 옵션을 사용하는 것은 좋은 방법이므로 활용해보시기 바랍니다.

`strcmp()` 함수를 사용한 것은 위와 같은 이유입니다.

```c
  if (strcmp(argv[1], "list") == 0) {
```

여기서 두 스트링이 같다는 뜻으로 이 함수는 `0`을 리턴한다는 점을 참고하세요.
스트링 비교는 다음과 같이 세 가지 값을 리턴합니다.

- 같은 경우: 0
- 첫 번째가 두 번째보다 사전순으로 먼저 오는 경우: 음수
- 그렇지 않은 경우: 양수

이것은 자바스크립트<L>JavaScript</L>의 [비교 함수][js-compare]나 자바<L>Java</L>의 [비교 함수][java-compare]처럼, 다른 프로그래밍 언어에서도 나타나는 패턴이기도 합니다.

[js-compare]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare
[java-compare]: https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Comparable.html#compareTo(T)

이렇게 세 가지 값으로 리턴하는 이유는, 숫자의 경우를 생각해보면 자연스럽게 이해됩니다.
예를 들어, `1`과 `2`를 봅시다.

```c
1 - 2;
```

이 결과는 음수인데, `1`이 `2`보다 먼저 옵니다.
이런 식으로 뺄셈을 한다면, 첫 번째가 먼저 오는 경우 결과는 항상 음수입니다.
나머지 두 경우도 이와 같습니다.

스트링마다 가상의 순번이 매겨져있다고 생각해보세요.
이 순번 끼리 뺄셈할때, 첫 번째가 먼저 오는 경우 결과는 음수가 됩니다.
이런 식으로 일반화해서 이해해볼 수 있습니다.

## 예외 처리: `else` 조건문과 `fprintf()` 함수

방금 만든 프로그램은 다음과 같이 실행하면 오류가 발생합니다.

```c
Segmentation fault
```

이것은 잘못된 메모리 주소로 접근했기 때문입니다.

그 이유를 자세히 설명해보겠습니다.
실행 시 커맨드라인 인자를 주지 않았기 때문에, `argv` 배열은 첫 번째 원소에 프로그램 이름만 갖게 됩니다.
따라서 `argv[1]`는 널 포인터이고, 문자열 비교 시 여기에 접근합니다.

```c
  if (strcmp(argv[1], "list") == 0) {
```

따라서 `argc` 값을 통해 커맨드라인 인자가 있는지 먼저 확인하는 것이 중요합니다.
다음 조건문을 `strcmp` 사용하기 전에 추가합시다.

```c
  if (argc == 1) {
    fprintf(stderr, "Error: no option given.\n");
    return EXIT_FAILURE;
  }
```

`fprintf()` 함수는 파일을 대상으로 프린트하는 함수입니다.
여기서는 자세한 설명 대신, 오류 메시지를 프린트하기 위한 방법이라고 정리하고 넘어가겠습니다.
`EXIT_FAILURE` 상수는 비정상적인 종료를 나타내는 종료 코드입니다.

이어서, 지원하지 않는 커맨드라인 인자 또한 처리합니다.
즉 `strcmp()` 함수로 비교했을 때, `list` 스트링이 아닌 경우가 됩니다.
이것은 기존 코드에 다음과 같이 이어서 만들 수 있습니다.

```c
  if (strcmp(argv[1], "list") == 0) {
    size_t size = (sizeof tasks) / (sizeof tasks[0]);
    print_tasks(tasks, size);
    
    return EXIT_SUCCESS;
  // [!code ++:3]
  } else {
    fprintf(stderr, "Error: bad option '%s'.\n", argv[1]);
    return EXIT_FAILURE;
  }
```

앞서 `if` 조건문에 해당하지 않는 나머지 경우를 `else` 조건문에서 처리합니다.
하지만 `if` 조건문은 마지막에 리턴하기 때문에, 다음과 같이 쓸 수도 있습니다.

```c
  if (strcmp(argv[1], "list") == 0) {
    size_t size = (sizeof tasks) / (sizeof tasks[0]);
    print_tasks(tasks, size);
    
    return EXIT_SUCCESS;
  // [!code --:3]
  } else {
    fprintf(stderr, "Error: bad option '%s'.\n", argv[1]);
    return EXIT_FAILURE;
  }

  // [!code ++:2]
  fprintf(stderr, "Error: bad option '%s'.\n", argv[1]);
  return EXIT_FAILURE;
```

여기서는 이 스타일로 코드를 유지하겠습니다.

실행하면 다음과 같이 예외 상황을 잘 처리합니다.

```shellsession
$ ./todo
Error: no option given.
$ ./todo foo
Error: bad option 'foo'.
```

이런 오류 메시지는 다음과 같이 수집할 수도 있습니다.

```shellsession
$ ./todo foo 2> log
$ cat log
Error: bad option 'foo'.
```

이에 대한 설명은 셸의 내용이므로 여기서는 다루지 않겠습니다.
여기까지 셸로부터 인자를 받고 셸에 오류 메시지를 프린트하는, 셸과 상호작용하는 방법을 살펴봤습니다.

## 코드 정리: 책임 분리

`list` 옵션을 처리하는 코드를 함수로 분리해봅시다.

```c
  if (strcmp(argv[1], "list") == 0) {
    // [!code --:4]
    size_t size = (sizeof tasks) / (sizeof tasks[0]);
    print_tasks(tasks, size);
    
    return EXIT_SUCCESS;
    // [!code ++:1]
    return list();
  }
```

이를 통해 `main()` 함수는 오직 커맨드라인 인자의 처리만 맡습니다.

`list()` 함수의 기본적인 구조는 다음과 같습니다.

```c
int list(void) {
  size_t size = (sizeof tasks) / (sizeof tasks[0]);
  print_tasks(tasks, size);

  return EXIT_SUCCESS;
}
```

여기에 다음과 같은 작업이 필요합니다.

- `tasks` 배열도 `list()` 함수에 옮기기
- `list()` 함수의 프로토타입 선언

이 작업은 간단하므로 직접 해보는 것으로 남기고 넘어가겠습니다.



# `list` 옵션 완성하기

지금까지 겉으로 보이는 동작은 완성했지만, 실제로는 임시로 만든 부분에 의존하고 있습니다.
즉 할 일을 어딘가에서 가져오지 않고, 이미 가져왔다고 가정합니다.

여기서는 데이터를 파일로 보관함으로써 `list` 옵션을 완성할 것입니다.
이에 필요한 함수가 표준 라이브러리에 잘 만들어져 있으므로 이것을 이용해보겠습니다.

`stdio.h` 같은 헤더 파일에 어떤 함수가 있는지 확인하려면, 직접 열어서 보는 것보다 [레퍼런스][cref-stdio] 같은 자료를 활용하는 편이 낫습니다.
여기에는 각 함수의 파라미터와 리턴 값이 정리되어 있으니 필요하다면 참고해보시기 바랍니다.

[cref-stdio]: https://cppreference.com/w/c/header/stdio.html

## 파일 열기: `fopen()` 함수

다음과 같이 `list()` 함수의 처음에 파일을 열어봅시다.

```c
  FILE* file = fopen("./.todo_list", "r");
  if (file == 0) {
    perror("fopen() failed");
    return EXIT_FAILURE;
  }
```

첫 줄에서 파일을 읽기 모드로 열기 위해 `"r"`을 인자로 넘깁니다.
이어서 실패하는 경우를 처리합니다.

이렇게 연 파일은 `FILE*` 타입의 포인터로 주어집니다.
라이브러리 함수를 쓰는 입장에서는 이 타입이 구체적으로 무엇인지 신경쓰지 않도록 만들어졌습니다.
이러한 것을 불투명한 타입<L>opaque type</L>이라고도 부릅니다.

실행해보면 파일이 없다는 오류 메시지가 나올 수 있습니다.

```shellsession
$ ./todo list
fopen() failed: No such file or directory
```

이 메시지는 `perror()` 함수가 오류의 원인을 알아서 프린트해준 것입니다.

`fopen()` 함수는 파일이 있다고 가정하기 때문에, 다음과 같이 미리 준비해둡시다.

```shellsession
$ echo -e "1\tLearn C\t0" > .todo_list
$ echo -e "2\tGet a coffee\t1" >> .todo_list
$ echo -e "3\tTake a walk\t0" >> .todo_list
```

여기서는 각 `task` 구조체의 각 필드 값이 탭 문자로 구분된다고 가정하겠습니다.

## 파일 읽기: `fgets()` 함수

이 파일의 내용을 한 줄씩 읽어봅시다.
방금의 코드에 이어서 작성합니다.

```c
  char buffer[1024] = { 0 };
  while (fgets(buffer, sizeof buffer, file) != 0) {
    printf("%s", buffer);
  }
```

`buffer` 배열의 모든 원소를 `0`으로 초기화합니다.
내용을 읽은 결과는 `buffer` 배열에 담깁니다.

앞서 배열은 다음과 같이 개수를 명시하지 않았습니다.

```c
  char name[] = "Learn C";
```

이것은 컴파일러가 알아서 세도록 만듭니다.
반면 위 `buffer` 배열과 같이 개수를 정해줄 수도 있습니다.

`while` 반복문은 괄호 안의 조건이 참인 동안 반복합니다.
`fgets()` 함수는 파일의 끝에 도달하면 널 포인터를 리턴하므로, 자연스럽게 모든 줄을 차례로 읽게 됩니다.

실행해보면 파일의 내용을 그대로 프린트할 것입니다. (확인해보세요.)

한편, 파일은 필요가 없을 때 닫는 것이 좋습니다.

```c
  char buffer[1024] = { 0 };
  while (fgets(buffer, sizeof buffer, file) != 0) {
    printf("%s", buffer);
  }

  // [!code ++:1]
  fclose(file);
```

## 동적 메모리 할당: `malloc()` 함수

파일의 내용으로부터 구조체를 만들 차례입니다.
예를 들어, 다음 줄을 만났다고 해봅시다.

```text
1       Learn C 0
```

그러면 다음과 같은 구조체를 만들어내는 것이 목표입니다.

```c
  task t = {
    .id = 1,
    .name = "Learn C",
    .status = 0,
  };
```

이런 작업을 파싱<L>parsing</L>이라고도 부릅니다.

이를 위해 함수를 만들어봅시다.
스트링을 받아 파싱 결과를 포인터로 리턴합니다.

```c
task* parse_task(char* line) {
  task* t = malloc(sizeof(task));

  return t;
}
```

여기서 `malloc()` 함수에 크기를 인자로 넘기면, 그만큼 메모리 공간을 빌려서 포인터로 리턴해줍니다.
메모리의 동적 할당<L>dynamic allocation</L>이라고도 부릅니다.

이런 작업이 왜 필요할까요?
다음 코드를 예로 들어 봅시다.

```c
task parse_task(char* line) {
  task t = { 0 };

  return t;
}
```

이 함수가 호출되면, 변수를 위해 메모리 공간을 빌리게 됩니다.
그리고 함수가 끝나면, 빌린 메모리는 자동으로 반납합니다.
비록 그런 코드를 직접 쓴 적은 없지만, C 언어는 그런 메모리 관리를 알아서 맡습니다.

그런데 변수의 주소를 리턴하도록 바꾸면 어떻게 될까요?

```c
task* parse_task(char* line) {
  task t = { 0 };

  return &t;
}
```

함수가 끝나서 메모리 공간은 반납했는데, 리턴 값은 여전히 그 주소를 가리키고 있습니다.
이것은 댕글링 포인터<L>dangling pointer</L>라고도 부르며, 여기에 접근하는 것은 정상적인 동작이 아닙니다.

따라서 자동으로 빌리고 반납하는 방식 대신, 프로그래머가 직접 빌리고 반납할 필요가 생깁니다.
`malloc()` 함수는 그런 식으로 메모리를 빌리는 함수입니다.

## 파싱하기: `sscanf()` 함수

구체적인 파싱은 `sscanf()` 함수에 맡길 수 있습니다.

```c
task* parse_task(char* line) {
  // [!code ++:4]
  int id = 0;
  char name[1024] = { 0 };
  int status = 0;
  sscanf(line, "%d\t%s\t%d", &id, name, &status);

  task* t = malloc(sizeof(task));

  return t;
```

이 함수는 스트링으로부터 값을 가져옵니다.
`printf()` 함수가 하는 일의 정반대라고 볼 수 있습니다.

예를 들어, 다음은 `id` 변수에 `42`가 기록됩니다.

```c
  sscanf("42", "%d", &id);
```

각 필드는 탭 문자로 구분된다고 했으므로, 실제로는 다음과 같이 읽게 됩니다.

```c
  sscanf("1\tLearn C\t0", "%d\t%s\t%d", &id, name, &status);
```

이렇게 읽은 값을 필드에 담아 리턴합니다.

```c
  task* t = malloc(sizeof(task));

  // [!code ++:4]
  t->id = id;
  t->name = malloc(strlen(name) + 1);
  strcpy(t->name, name);
  t->status = status;

  return t;
```

여기서 `strlen()` 함수는 스트링의 길이를 리턴하고, 하나를 더한 것은 널 문자를 포함하기 위함입니다.
`strcpy()` 함수는 스트링을 복사합니다.

이렇게 만든 파싱 함수를 `list()` 함수에서 사용합시다.

```c
  while (fgets(buffer, sizeof buffer, file) != 0) {
    // [!code --:1]
    printf("%s", buffer);
    // [!code ++:2]
    task* t = parse_task(buffer);
    print_task(t);
  }
```

이제 손수 입력했던 `tasks` 배열은 버려도 됩니다.
파일로부터 직접 읽기 때문입니다.

하지만 실행해보면 정상적으로 동작하지 않습니다. (확인해보세요.)

왜일까요?
`%s` 지정자는 공백 문자를 포함하지 않기 때문입니다.
예를 들어, 다음 코드는 `name`에 `Take`만 들어갑니다.

```c
  sscanf("Take a walk", "%s", name);
```

여기서는 탭 문자까지 읽고 싶기 때문에, 다음과 같이 고칩니다.

```c
  // [!code --:1]
  sscanf(str, "%d\t%s\t%d", &id, name, &status);
  // [!code ++:1]
  sscanf(str, "%d\t%[^\t]\t%d", &id, name, &status);
```

포맷 지정자로 쓴 `%[^\t]`는 탭 문자를 제외한 모든 문자를 의미합니다.

이제 정상적으로 동작합니다.

```shellsession
$ ./todo list
1: Learn C      To-do
2: Get a coffee Done
3: Take a walk  To-do
```

## 메모리 해제: `free()` 함수

`malloc()` 함수로 빌린 메모리는 직접 반납해야합니다.
이것은 메모리 해제<L>release</L>라고도 부릅니다.

해제를 하지 않으면 다른 곳에서 쓸 수 없는 메모리 공간으로 남게 됩니다.
이것은 메모리 누수<L>memory leak</L>라고도 부르는 버그입니다.
따라서 필요가 없어질 때 바로 반납하는 것이 원칙입니다.

여기서는 해제를 맡는 함수를 따로 만들어봅시다.

```c
  while (fgets(buffer, sizeof buffer, file) != 0) {
    task* t = parse_task(buffer);
    print_task(t);
    // [!code ++:1]
    t = free_task(&task);
  }
```

이렇게 호출한 `free_task()` 함수는 메모리를 해제하고 널 포인터를 리턴할 것입니다.
기본적인 구현은 다음과 같습니다.

```c
task* free_task(task* t) {
  if (t == 0) {
    return 0;
  }

  free(t);

  return 0;
}
```

직접 메모리 해제를 맡는 것은 `free()` 함수입니다.
널 포인터가 넘어온 경우, 아무것도 하지 않고 리턴합니다.

동적으로 할당한 메모리가 하나 더 있는데, 바로 `name` 필드입니다.
마찬가지로 해제합니다.

```c
  if (t == 0) {
    return 0;
  }

  // [!code ++:4]
  if (t->name != 0) {
    free(t->name);
    t->name = 0;
  }

  free(t);
```

이와 같이 메모리를 해제하면 그 포인터는 널 포인터로 만듭니다.
그리고 다음에 널 포인터를 만나면 아무것도 하지 않고 넘어갈 것입니다.
이미 해제한 메모리를 다시 해제하는 것 또한 정상적인 동작이 아니므로 방지하는 것이 좋습니다.

잠깐 앞서 언급했던 주의 사항을 정리하고 넘어가겠습니다.

- `malloc()` 함수로 동적 할당한 메모리는 `free()` 함수로 해제해야 한다.
- 해제한 메모리는 접근을 피해야 한다.
- 두 번 해제하는 일 또한 피해야 한다.

요약하자면, 동적 할당했다면 반드시 한 번 해제해야 합니다.

## 상수 만들기: `#define` 지시문

앞서 헤더를 포함하는데 `#include` 키워드를 썼습니다.
이것은 엄밀히 얘기하자면 C 언어가 아니라, C 컴파일러가 컴파일 전에 처리하는 명령입니다.
그 단계를 전처리<L>preprocessing</L>라고도 부릅니다.
그리고 이때 처리되는 키워드를 전처리 지시문<L>directive</L>라고 부릅니다.

또 다른 지시자인 `#define`은 어떤 단어를 만나면 다른 단어를 바꾸도록 만듭니다.
이것은 매크로<L>macro</L>라고도 부릅니다.
이를 이용해서 상수를 정의할 수 있습니다.

```c
#define TODO_PATH "./.todo_list"
```

이것은 다음과 같이 자연스럽게 쓸 수 있습니다.

```c
  // [!code --:1]
  FILE* file = fopen("./.todo_list", "r");
  // [!code ++:1]
  FILE* file = fopen(TODO_PATH, "r");
```

매직 넘버를 하나 더 고쳐봅시다.
다음과 같이 버퍼 사이즈 상수를 만듭니다.

```c
#define BUFFER_SIZE 1024
```

그리고 이름 없이 사용했던 크기를 고칩니다.

```c
  // [!code --:1]
  char buffer[1024] = { 0 };
  // [!code ++:1]
  char buffer[BUFFER_SIZE] = { 0 };
```

이런 식으로 다른 `buffer` 배열의 크기도 수정해보시기 바랍니다.



# 코드를 파일로 분리하기

다소 길어진 코드를 읽게 좋게 나눌 수는 없을까요?
마치 하나의 함수가 하나의 책임을 맡는 것처럼, 하나의 파일 또한 하나의 목적을 갖도록 만드는 것이 좋습니다.

여기서는 여러 파일로 나누는 방법을 알아보고, 헤더 파일도 직접 만들어봅니다.

## 파일 나누기

여기서는 `task` 구조체와 관련된 코드를 분리해보겠습니다.
일반적으로 C 언어에서는 선언이 담긴 헤더 파일과 구현이 담긴 파일을 분리합니다.

먼저 아래와 같은 `main.c` 파일의 내용을 `task.h` 파일로 옮겨봅시다.

```c
typedef struct task {
  int id;
  char* name;
  int status;
} task;

enum status { to_do, done };

task* free_task(task* task);
```

`main.c` 파일에서는 이 헤더 파일을 가져옵니다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// [!code ++:1]
#include "task.h"
```

따옴표로 감싼 것은 표준 라이브러리를 쓰는 대신 직접 만든 헤더 파일을 쓰겠다는 의미입니다.
이제 `task.c` 파일을 다음과 같이 옮깁니다.

```c
#include <stdlib.h>
#include "task2.h"

task* free_task(task* t) {
  if (t == 0) {
    return 0;
  }

  if (t->name != 0) {
    free(t->name);
    t->name = 0;
  }

  free(t);

  return 0;
}

```

이렇게 나눈 코드를 다음과 같이 컴파일할 수 있습니다.

```c
$ gcc -o todo todo.c task.c
```

이전과 같이 동작하는지 확인해보세요.

## 인클루드 가드

헤더 파일은 처음과 끝에 인클루드 가드<L>include guard</L>를 포함하는 것이 보통입니다.

```c
// [!code ++:2]
#ifndef TASK_H
#define TASK_H

typedef struct task {
  int id;
  char* name;
  int status;
} task;

enum status { to_do, done };

void free_task(task** task);

// [!code ++:1]
#endif
```

`#ifndef`와 `#endif`는 한 쌍으로, 조건문을 수행하는 지시자입니다.
그래서 이 작업은 `TASK_H`가 정의되어 있지 않을 때 그것을 정의하고 내용을 포함합니다.

이것이 필요한 이유는, 헤더 파일이 복잡해지면 어떤 헤더 파일은 간접적으로 여러 번 가져오는 일이 생기기 때문입니다.
이때 인클루드 가드는 오직 한 번만 포함되게끔 만들어줍니다.

앞서 소개한 내용을 이용해 `main.c` 파일을 더 나눠보시기 바랍니다.
여기서는 설명의 편의를 위해 이대로 진행하겠습니다.



# `add` 옵션 완성하기

여기서는 다음 동작을 완성하는 것이 목표입니다.

```shellsession
$ todo add "Go to bed"
Added task 'Go to bed'.
```

이것이 실제로 파일에 기록하도록 만들어볼 것입니다.

## `add` 옵션 처리하기

`main()` 함수에 `add` 옵션을 처리하도록 추가합니다.

```c
  if (strcmp(argv[1], "list") == 0) {
    return list();
  }
  // [!code ++:3]
  if (strcmp(argv[1], "add") == 0) {
    return add(argv[2]);
  }
```

`add()` 함수는 다음과 같이 할 일의 이름을 받아서 파일에 기록할 것입니다.

```c
int add(char* name);
```

구현은 기본적으로 다음과 같습니다.

```c
int add(char* name) {
  int last_id = get_last_id();
  append_task(last_id + 1, name);

  printf("Task '%s' added\n", name);

  return EXIT_SUCCESS;
}
```

기존 할 일의 마지막 순번을 구하고, 그 다음 순번으로 파일에 기록합니다.
마지막 순번을 구하는 `get_last_id()` 함수는 임시로 만들어둡시다.

```c
int get_last_id(void) {
  return 3;
}
```

이 함수의 구현은 직접 해보는 것으로 남기고 넘어가겠습니다.

## 파일에 쓰기: `fprintf()` 함수

이어서 `append_task()` 함수는 파일에 할 일을 추가합니다.

```c
void append_task(int id, char* name) {
  FILE* file = fopen(TODO_PATH, "a");
  if (file == 0) {
    perror("fopen() failed");
    return;
  }

  fprintf(file, "%u\t%s\t%u\n", id, name, to_do);

  fclose(file);
}
```

앞서 해온 것과 비슷하므로 이해하기 어렵지 않을 것입니다.
`fopen()` 함수에 넘긴 `"a"` 인자는, 내용을 마지막 줄에 추가하도록 만듭니다.
그리고 `fprintf()` 함수로 파일에 내용을 씁니다.

이제 다음과 같이 실행할 수 있습니다.

```shellsession
$ ./todo add "Go to bed"
Added task 'Go to bed'.
```

목록을 프린트해보면 실제로 할 일이 추가되어 있을 것입니다. (확인해보세요.)

## 예외 처리

`append_task()` 함수는 오류가 발생했을 때 호출한 쪽에 어떠한 정보도 주지 못합니다.
따라서 다음과 같이 리턴 값을 만들어주겠습니다.

```c
  if (file == 0) {
    perror("fopen() failed");
    // [!code --:1]
    return;
    // [!code ++:1]
    return 0;
  }
  fprintf(file, "%s\n", buffer);
  fclose(file);

  // [!code --:1]
  return;
  // [!code ++:1]
  return 1;
}
```

이렇게 만든 이유는, C 언어에서 `1`은 참 값으로, `0`은 거짓 값으로 처리되기 때문입니다.
다음과 같은 조건문을 예로 들어 봅시다.

```c
if (0) {
  printf("It's true.\n");
}
```

조건의 `0`은 거짓으로 처리되어 조건문은 실행되지 않습니다.

이와 같이 `add()` 함수에서 오류를 처리합니다.

```c
  // [!code --:1]
  append_task(last_id + 1, name);
  // [!code ++:3]
  if (append_task(last_id + 1, name)) {
    return EXIT_FAILURE;
  }
```

## 불 타입: `bool`

앞서 참 값과 거짓 값을 숫자로 리턴했지만, `stdbool.h` 헤더가 제공하는 `bool` 타입을 이용해 좀더 의미있는 이름을 쓸 수도 있습니다.

```c
// [!code --:1]
int append_task(int id, char* name);
// [!code ++:1]
bool append_task(int id, char* name);
```

참 값과 거짓 값은 다음과 같이 쓸 수 있습니다.

```c
  if (file == 0) {
    perror("fopen() failed");
    // [!code --:1]
    return 0;
    // [!code ++:1]
    return false;
  }
  fprintf(file, "%s\n", buffer);
  fclose(file);

  // [!code --:1]
  return 1;
  // [!code ++:1]
  return true;
```

참과 거짓을 나타내는 타입은 불리언<L>Boolean</L> 타입 또는 불<L>Bool</L> 타입이라고 부르고, 다른 프로그래밍 언어에서는 기본적으로 제공하기도 합니다.
하지만 C 언어는 역사적으로 늦게 라이브러리로서 도입되었으며, 쓰지 않는 경우도 많다는 사실을 참고하세요.

## 문서화: 코멘트

앞서 `append_task()` 함수가 오류 발생 시 거짓 값을 리턴하도록 만들었습니다.

그런데 이러한 사실은 구현을 들여다봐야 알 수 있습니다.
따라서 코멘트를 남김으로서 이해를 도울 수도 있습니다.

```c
/* Returns false if failed. */
bool append_task(int id, char* name);
```

`/*`와 `*/` 사이의 모든 문자는 컴파일러가 무시합니다.

또는 다음과 같이 간단히 쓸 수도 있습니다.

```c
// Returns false if failed.
bool append_task(int id, char* name);
```

`//`는 해당 줄의 끝까지 코멘트로 만듭니다.
그리고 이런 작업을 문서화<L>documentation</L>라고 부릅니다.

하지만 많은 경우에 코멘트가 정말 필요한지에 대해서는 논란의 여지가 있기도 합니다.
예를 들어, 다음과 같은 코멘트는 의미가 없습니다.

```c
  // Return true
  return true;
```

무엇을 하는지는 이미 코드가 말해주기 때문입니다.
반면, 왜 하는지에 대한 설명은 효과적인 코멘트가 될 수 있습니다.

또한 코멘트의 내용은 코드와 불일치하더라도 컴파일러는 알 수 없다는 점을 참고하세요.
코드 자체가 이미 정확한 문서이므로, 코드를 읽기 좋게 만드는 것이 나을 수도 있습니다.
또는 코드로서 표현할 수 없는 부분을 보충하는 것이 효과적입니다.

# 마치며

본문의 소스 코드는 [깃허브][gh]<L>GitHub</L>에서 확인할 수 있습니다.

[gh]: https://github.com/wcho21/langwalk/tree/main/c

## 레퍼런스

- *The C Programming Language* (Brian Kernighan, Dennis Ritchie, 1988), 또는 *C 언어 프로그래밍* (휴먼싸이언스, 2016)
- *The Practice of Programming* (Brian Kernighan, Rob Pike, 1999), 또는 *프로그래밍 수련법* (인사이트, 2008)
- *Modern C* (Jens Gustedt, 2019), 또는 *모던 C* (길벗, 2022)
- [cppreference.com][cref]: C 언어 온라인 레퍼런스.

[cref]: https://cppreference.com/w/c.html
